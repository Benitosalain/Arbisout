{"ast":null,"code":"const EventEmitter = require('events');\nconst OriginalDatastore = require('@seald-io/nedb');\nconst Cursor = require('./Cursor');\n\n/**\n * @summary\n * As of v2.0.0 the Datastore class extends node's built \n * in EventEmitter class and implements each method as an event\n * plus additional error events. It also inherits the `compaction.done`\n * event from nedb but for consistency, in this library the event\n * was renamed to `compactionDone`.\n *\n * All event callbacks will be passed the same type of values,\n * the first being the datastore, then the operation result (if there is any)\n * and then the arguments of the called method. (Check out the first example!)\n *\n * All events have a matching error event that goes by the name of `${method}Error`,\n * for example `findError` or `loadError`. The callbacks of these events will receive\n * the same parameters as the normal event handlers except that instead of the \n * operation result there will be an operation error. (Check out the second example!)\n *\n * A generic `__error__` event is also available. This event will be emitted at any of\n * the above error events. The callbacks of this event will receive the same parameters\n * as the specific error event handlers except that there will be one more parameter \n * passed between the datastore and the error object, that being the name of the method\n * that failed. (Check out the third example!)\n *\n * @example\n * let datastore = Datastore.create()\n * datastore.on('update', (datastore, result, query, update, options) => {\n * })\n * datastore.on('load', (datastore) => {\n *     // this event doesn't have a result\n * })\n * datastore.on('ensureIndex', (datastore, options) => {\n *     // this event doesn't have a result\n *     // but it has the options argument which will be passed to the\n *     // event handlers\n * })\n * datastore.on('compactionDone', (datastore) => {\n *     // inherited from nedb's compaction.done event\n * })\n *\n * @example\n * let datastore = Datastore.create()\n * datastore.on('updateError', (datastore, error, query, update, options) => {\n * })\n * datastore.on('loadError', (datastore, error) => {\n * })\n * datastore.on('ensureIndexError', (datastore, error, options) => {\n * })\n *\n * @example\n * let datastore = Datastore.create()\n * datastore.on('__error__', (datastore, event, error, ...args) => {\n *     // for example\n *     // datastore, 'find', error, [{ foo: 'bar' }, {}]\n * })\n * \n * @class\n */\nclass Datastore extends EventEmitter {\n  /**\n   * Create a database instance.\n   *\n   * Use this over `new Datastore(...)` to access\n   * original nedb datastore properties, such as\n   * `datastore.persistence`.\n   *\n   * Note that this method only creates the `Datastore`\n   * class instance, not the datastore file itself.\n   * The file will only be created once an operation\n   * is issued against the datastore or if you call\n   * the `load` instance method explicitly.\n   * \n   * The path (if specified) will be relative to `process.cwd()`\n   * (unless an absolute path was passed).\n   *\n   * For more information visit:\n   * https://github.com/louischatriot/nedb#creatingloading-a-database\n   * \n   * @param  {string|Object} [pathOrOptions]\n   * @return {Proxy<static>}\n   */\n  static create(pathOrOptions) {\n    return new Proxy(new this(pathOrOptions), {\n      get(target, key) {\n        return target[key] ? target[key] : target.__original[key];\n      },\n      set(target, key, value) {\n        return Object.prototype.hasOwnProperty.call(target.__original, key) ? target.__original[key] = value : target[key] = value;\n      }\n    });\n  }\n\n  /**\n   * Datastore constructor...\n   *\n   * You should use `Datastore.create(...)` instead\n   * of `new Datastore(...)`. With that you can access\n   * the original datastore's properties such as `datastore.persistence`.\n   *\n   * Create a Datastore instance.\n   * \n   * Note that the datastore will be created\n   * relative to `process.cwd()`\n   * (unless an absolute path was passed).\n   * \n   * It's basically the same as the original:\n   * https://github.com/louischatriot/nedb#creatingloading-a-database\n   * \n   * @param  {string|Object} [pathOrOptions]\n   * @return {static}\n   */\n  constructor(pathOrOptions) {\n    super();\n    const datastore = new OriginalDatastore(typeof pathOrOptions === 'string' ? {\n      filename: pathOrOptions\n    } : pathOrOptions);\n    Object.defineProperties(this, {\n      __loaded: {\n        enumerable: false,\n        writable: true,\n        value: null\n      },\n      __original: {\n        configurable: true,\n        enumerable: false,\n        writable: false,\n        value: datastore\n      }\n    });\n    this.__original.on('compaction.done', () => {\n      this.emit('compactionDone', this);\n    });\n  }\n\n  /**\n   * Load the datastore.\n   *\n   * Note that you don't necessarily have to call\n   * this method to load the datastore as it will\n   * automatically be called and awaited on any\n   * operation issued against the datastore\n   * (i.e.: `find`, `findOne`, etc.).\n   * \n   * @return {Promise<undefined>}\n   */\n  load() {\n    if (!(this.__loaded instanceof Promise)) {\n      this.__loaded = this.__original.loadDatabaseAsync().then(() => this.broadcastSuccess('load')).catch(error => {\n        this.broadcastError('load', error);\n        throw error;\n      });\n    }\n    return this.__loaded;\n  }\n\n  /**\n   * Find documents that match the specified `query`.\n   *\n   * It's basically the same as the original:\n   * https://github.com/louischatriot/nedb#finding-documents\n   *\n   * There are differences minor in how the cursor works though.\n   *\n   * @example\n   * datastore.find({ ... }).sort({ ... }).exec().then(...)\n   *\n   * @example\n   * datastore.find({ ... }).sort({ ... }).then(...)\n   *\n   * @example\n   * // in an async function\n   * await datastore.find({ ... }).sort({ ... })\n   * \n   * @param  {Object} [query]\n   * @param  {Object} [projection]\n   * @return {Cursor}\n   */\n  find(query = {}, projection) {\n    if (typeof projection === 'function') {\n      projection = {};\n    }\n    return new Cursor(this, 'find', query, projection);\n  }\n\n  /**\n   * Find a document that matches the specified `query`.\n   *\n   * It's basically the same as the original:\n   * https://github.com/louischatriot/nedb#finding-documents\n   *\n   * @example\n   * datastore.findOne({ ... }).then(...)\n   *\n   * @example\n   * // in an async function\n   * await datastore.findOne({ ... }).sort({ ... })\n   * \n   * @param  {Object} [query]\n   * @param  {Object} [projection]\n   * @return {Cursor}\n   */\n  findOne(query = {}, projection) {\n    if (typeof projection === 'function') {\n      projection = {};\n    }\n    return new Cursor(this, 'findOne', query, projection);\n  }\n\n  /**\n   * Insert a document or documents.\n   *\n   * It's basically the same as the original:\n   * https://github.com/louischatriot/nedb#inserting-documents\n   * \n   * @param  {Object|Object[]} docs\n   * @return {Promise<Object|Object[]>}\n   */\n  async insert(docs) {\n    await this.load();\n    try {\n      const result = await this.__original.insertAsync(docs);\n      this.broadcastSuccess('insert', docs);\n      return result;\n    } catch (error) {\n      this.broadcastError('insert', error, docs);\n      throw error;\n    }\n  }\n\n  /**\n   * Insert a single document.\n   *\n   * This is just an alias for `insert` with object destructuring\n   * to ensure a single document.\n   * \n   * @param  {Object} doc\n   * @return {Promise<Object>}\n   */\n  insertOne({\n    ...doc\n  }) {\n    return this.insert(doc);\n  }\n\n  /**\n   * Insert multiple documents.\n   *\n   * This is just an alias for `insert` with array destructuring\n   * to ensure multiple documents.\n   * \n   * @param  {Object[]} docs\n   * @return {Promise<Object[]>}\n   */\n  insertMany([...docs]) {\n    return this.insert(docs);\n  }\n\n  /**\n   * Update documents that match the specified `query`.\n   *\n   * It's basically the same as the original:\n   * https://github.com/louischatriot/nedb#updating-documents\n   *\n   * If you set `options.returnUpdatedDocs`,\n   * the returned promise will resolve with\n   * an object (if `options.multi` is `false`) or\n   * with an array of objects.\n   * \n   * @param  {Object} query\n   * @param  {Object} update\n   * @param  {Object} [options]\n   * @return {Promise<number|Object|Object[]>}\n   */\n  async update(query, update, options = {}) {\n    await this.load();\n    try {\n      const {\n        numAffected,\n        affectedDocuments\n      } = await this.__original.updateAsync(query, update, options);\n      const result = options.returnUpdatedDocs ? affectedDocuments : numAffected;\n      this.broadcastSuccess('update', result, query, update, options);\n      return result;\n    } catch (error) {\n      this.broadcastError('update', error, query, update, options);\n      throw error;\n    }\n  }\n\n  /**\n   * Update a single document that matches the specified `query`.\n   *\n   * This is just an alias for `update` with `options.multi` set to `false`.\n   * \n   * @param  {Object} query\n   * @param  {Object} update\n   * @param  {Object} [options]\n   * \n   * @return {Promise<number|Object>}\n   */\n  updateOne(query, update, options = {}) {\n    return this.update(query, update, {\n      ...options,\n      multi: false\n    });\n  }\n\n  /**\n   * Update multiple documents that match the specified `query`.\n   *\n   * This is just an alias for `update` with `options.multi` set to `true`.\n   *\n   * @param  {Object} query\n   * @param  {Object} update\n   * @param  {Object} [options]\n   * \n   * @return {Promise<number|Object[]>}\n   */\n  updateMany(query, update, options = {}) {\n    return this.update(query, update, {\n      ...options,\n      multi: true\n    });\n  }\n\n  /**\n   * Remove documents that match the specified `query`.\n   *\n   * It's basically the same as the original:\n   * https://github.com/louischatriot/nedb#removing-documents\n   * \n   * @param  {Object} [query]\n   * @param  {Object} [options]\n   * @return {Promise<number>}\n   */\n  async remove(query = {}, options = {}) {\n    await this.load();\n    try {\n      const result = await this.__original.removeAsync(query, options);\n      this.broadcastSuccess('remove', result, query, options);\n      return result;\n    } catch (error) {\n      this.broadcastError('remove', error, query, options);\n      throw error;\n    }\n  }\n\n  /**\n   * Remove the first document that matches the specified `query`.\n   *\n   * This is just an alias for `remove` with `options.multi` set to `false`.\n   * \n   * @param  {Object} [query]\n   * @param  {Object} [options]\n   * \n   * @return {Promise<number>}\n   */\n  removeOne(query, options = {}) {\n    return this.remove(query, {\n      ...options,\n      multi: false\n    });\n  }\n\n  /**\n   * Remove all documents that match the specified `query`.\n   *\n   * This is just an alias for `remove` with `options.multi` set to `true`.\n   * \n   * @param  {Object} [query]\n   * @param  {Object} [options]\n   * \n   * @return {Promise<number>}\n   */\n  removeMany(query, options = {}) {\n    return this.remove(query, {\n      ...options,\n      multi: true\n    });\n  }\n\n  /**\n   * Remove the first document that matches the specified `query`.\n   *\n   * This is just an alias for `removeOne`.\n   * \n   * @param  {Object} [query]\n   * @param  {Object} [options]\n   * \n   * @return {Promise<number>}\n   */\n  deleteOne(query, options) {\n    return this.removeOne(query, options);\n  }\n\n  /**\n   * Remove all documents that match the specified `query`.\n   *\n   * This is just an alias for `removeMany`.\n   * \n   * @param  {Object} [query]\n   * @param  {Object} [options]\n   * \n   * @return {Promise<number>}\n   */\n  deleteMany(query, options) {\n    return this.removeMany(query, options);\n  }\n\n  /**\n   * Count documents matching the specified `query`.\n   *\n   * It's basically the same as the original:\n   * https://github.com/louischatriot/nedb#counting-documents\n   *\n   * @example\n   * datastore.count({ ... }).limit(...).then(...)\n   *\n   * @example\n   * // in an async function\n   * await datastore.count({ ... })\n   * // or\n   * await datastore.count({ ... }).sort(...).limit(...)\n   * \n   * @param  {Object} [query]\n   * @return {Cursor}\n   */\n  count(query = {}) {\n    return new Cursor(this, 'count', query);\n  }\n\n  /**\n   * https://github.com/louischatriot/nedb#indexing\n   * \n   * @param  {Object} options\n   * @return {Promise<undefined>}\n   */\n  async ensureIndex(options) {\n    try {\n      const result = await this.__original.ensureIndexAsync(options);\n      this.broadcastSuccess('ensureIndex', result, options);\n      return result;\n    } catch (error) {\n      this.broadcastError('ensureIndex', error, options);\n      throw error;\n    }\n  }\n\n  /**\n   * https://github.com/louischatriot/nedb#indexing\n   * \n   * @param  {string} field\n   * @return {Promise<undefined>}\n   */\n  async removeIndex(field) {\n    try {\n      const result = await this.__original.removeIndexAsync(field);\n      this.broadcastSuccess('removeIndex', result, field);\n      return result;\n    } catch (error) {\n      this.broadcastError('removeIndex', error, field);\n      throw error;\n    }\n  }\n\n  /**\n   * Broadcasts operation success messages.\n   * \n   * @param  {string} op\n   * @param  {*}      result\n   * @param  {...*}   args\n   * \n   * @return {undefined}\n   * @private\n   */\n  broadcastSuccess(op, result, ...args) {\n    this.emit(op, this, result, ...args);\n    return this;\n  }\n\n  /**\n   * Broadcasts operation error messages.\n   * \n   * @param  {string} op\n   * @param  {Error}  error\n   * @param  {...*}   args\n   * \n   * @return {undefined}\n   * @private\n   */\n  broadcastError(op, error, ...args) {\n    this.emit(`${op}Error`, this, error, ...args);\n    this.emit('__error__', this, op, error, ...args);\n    return this;\n  }\n}\nmodule.exports = Datastore;","map":{"version":3,"names":["EventEmitter","require","OriginalDatastore","Cursor","Datastore","create","pathOrOptions","Proxy","get","target","key","__original","set","value","Object","prototype","hasOwnProperty","call","constructor","datastore","filename","defineProperties","__loaded","enumerable","writable","configurable","on","emit","load","Promise","loadDatabaseAsync","then","broadcastSuccess","catch","error","broadcastError","find","query","projection","findOne","insert","docs","result","insertAsync","insertOne","doc","insertMany","update","options","numAffected","affectedDocuments","updateAsync","returnUpdatedDocs","updateOne","multi","updateMany","remove","removeAsync","removeOne","removeMany","deleteOne","deleteMany","count","ensureIndex","ensureIndexAsync","removeIndex","field","removeIndexAsync","op","args","module","exports"],"sources":["C:/Users/benit/Music/arbisout/node_modules/nedb-promises/src/Datastore.js"],"sourcesContent":["const EventEmitter = require('events');\nconst OriginalDatastore = require('@seald-io/nedb');\nconst Cursor = require('./Cursor');\n\n/**\n * @summary\n * As of v2.0.0 the Datastore class extends node's built \n * in EventEmitter class and implements each method as an event\n * plus additional error events. It also inherits the `compaction.done`\n * event from nedb but for consistency, in this library the event\n * was renamed to `compactionDone`.\n *\n * All event callbacks will be passed the same type of values,\n * the first being the datastore, then the operation result (if there is any)\n * and then the arguments of the called method. (Check out the first example!)\n *\n * All events have a matching error event that goes by the name of `${method}Error`,\n * for example `findError` or `loadError`. The callbacks of these events will receive\n * the same parameters as the normal event handlers except that instead of the \n * operation result there will be an operation error. (Check out the second example!)\n *\n * A generic `__error__` event is also available. This event will be emitted at any of\n * the above error events. The callbacks of this event will receive the same parameters\n * as the specific error event handlers except that there will be one more parameter \n * passed between the datastore and the error object, that being the name of the method\n * that failed. (Check out the third example!)\n *\n * @example\n * let datastore = Datastore.create()\n * datastore.on('update', (datastore, result, query, update, options) => {\n * })\n * datastore.on('load', (datastore) => {\n *     // this event doesn't have a result\n * })\n * datastore.on('ensureIndex', (datastore, options) => {\n *     // this event doesn't have a result\n *     // but it has the options argument which will be passed to the\n *     // event handlers\n * })\n * datastore.on('compactionDone', (datastore) => {\n *     // inherited from nedb's compaction.done event\n * })\n *\n * @example\n * let datastore = Datastore.create()\n * datastore.on('updateError', (datastore, error, query, update, options) => {\n * })\n * datastore.on('loadError', (datastore, error) => {\n * })\n * datastore.on('ensureIndexError', (datastore, error, options) => {\n * })\n *\n * @example\n * let datastore = Datastore.create()\n * datastore.on('__error__', (datastore, event, error, ...args) => {\n *     // for example\n *     // datastore, 'find', error, [{ foo: 'bar' }, {}]\n * })\n * \n * @class\n */\nclass Datastore extends EventEmitter {\n    /**\n     * Create a database instance.\n     *\n     * Use this over `new Datastore(...)` to access\n     * original nedb datastore properties, such as\n     * `datastore.persistence`.\n     *\n     * Note that this method only creates the `Datastore`\n     * class instance, not the datastore file itself.\n     * The file will only be created once an operation\n     * is issued against the datastore or if you call\n     * the `load` instance method explicitly.\n     * \n     * The path (if specified) will be relative to `process.cwd()`\n     * (unless an absolute path was passed).\n     *\n     * For more information visit:\n     * https://github.com/louischatriot/nedb#creatingloading-a-database\n     * \n     * @param  {string|Object} [pathOrOptions]\n     * @return {Proxy<static>}\n     */\n    static create(pathOrOptions) {\n        return new Proxy(new this(pathOrOptions), {\n            get(target, key) {\n                return target[key]\n                    ? target[key]\n                    : target.__original[key];\n            },\n\n            set(target, key, value) {\n                return Object.prototype.hasOwnProperty.call(target.__original, key)\n                    ? (target.__original[key] = value)\n                    : (target[key] = value);\n            },\n        });\n    }\n\n    /**\n     * Datastore constructor...\n     *\n     * You should use `Datastore.create(...)` instead\n     * of `new Datastore(...)`. With that you can access\n     * the original datastore's properties such as `datastore.persistence`.\n     *\n     * Create a Datastore instance.\n     * \n     * Note that the datastore will be created\n     * relative to `process.cwd()`\n     * (unless an absolute path was passed).\n     * \n     * It's basically the same as the original:\n     * https://github.com/louischatriot/nedb#creatingloading-a-database\n     * \n     * @param  {string|Object} [pathOrOptions]\n     * @return {static}\n     */\n    constructor(pathOrOptions) {\n        super();\n\n        const datastore = new OriginalDatastore(\n            typeof pathOrOptions === 'string'\n                ? { filename: pathOrOptions }\n                : pathOrOptions,\n        );\n\n        Object.defineProperties(this, {\n            __loaded: {\n                enumerable: false,\n                writable: true,\n                value: null,\n            },\n\n            __original: {\n                configurable: true,\n                enumerable: false,\n                writable: false,\n                value: datastore,\n            },\n        });\n\n        this.__original.on('compaction.done', () => {\n            this.emit('compactionDone', this);\n        });\n    }\n\n    /**\n     * Load the datastore.\n     *\n     * Note that you don't necessarily have to call\n     * this method to load the datastore as it will\n     * automatically be called and awaited on any\n     * operation issued against the datastore\n     * (i.e.: `find`, `findOne`, etc.).\n     * \n     * @return {Promise<undefined>}\n     */\n    load() {\n        if ( ! (this.__loaded instanceof Promise)) {\n            this.__loaded = this.__original.loadDatabaseAsync()\n                .then(() => this.broadcastSuccess('load'))\n                .catch((error) => { this.broadcastError('load', error); throw error; });\n        }\n\n        return this.__loaded;\n    }\n\n    /**\n     * Find documents that match the specified `query`.\n     *\n     * It's basically the same as the original:\n     * https://github.com/louischatriot/nedb#finding-documents\n     *\n     * There are differences minor in how the cursor works though.\n     *\n     * @example\n     * datastore.find({ ... }).sort({ ... }).exec().then(...)\n     *\n     * @example\n     * datastore.find({ ... }).sort({ ... }).then(...)\n     *\n     * @example\n     * // in an async function\n     * await datastore.find({ ... }).sort({ ... })\n     * \n     * @param  {Object} [query]\n     * @param  {Object} [projection]\n     * @return {Cursor}\n     */\n    find(query = {}, projection) {\n        if (typeof projection === 'function') {\n            projection = {};\n        }\n\n        return new Cursor(this, 'find', query, projection);\n    }\n\n    /**\n     * Find a document that matches the specified `query`.\n     *\n     * It's basically the same as the original:\n     * https://github.com/louischatriot/nedb#finding-documents\n     *\n     * @example\n     * datastore.findOne({ ... }).then(...)\n     *\n     * @example\n     * // in an async function\n     * await datastore.findOne({ ... }).sort({ ... })\n     * \n     * @param  {Object} [query]\n     * @param  {Object} [projection]\n     * @return {Cursor}\n     */\n    findOne(query = {}, projection) {\n        if (typeof projection === 'function') {\n            projection = {};\n        }\n\n        return new Cursor(this, 'findOne', query, projection);\n    }\n\n    /**\n     * Insert a document or documents.\n     *\n     * It's basically the same as the original:\n     * https://github.com/louischatriot/nedb#inserting-documents\n     * \n     * @param  {Object|Object[]} docs\n     * @return {Promise<Object|Object[]>}\n     */\n    async insert(docs) {\n        await this.load();\n        try {\n            const result = await this.__original.insertAsync(docs);\n            this.broadcastSuccess('insert', docs);\n            return result;\n        } catch (error) {\n            this.broadcastError('insert', error, docs);\n            throw error;\n        }\n    }\n\n    /**\n     * Insert a single document.\n     *\n     * This is just an alias for `insert` with object destructuring\n     * to ensure a single document.\n     * \n     * @param  {Object} doc\n     * @return {Promise<Object>}\n     */\n    insertOne({ ...doc }) {\n        return this.insert(doc);\n    }\n\n    /**\n     * Insert multiple documents.\n     *\n     * This is just an alias for `insert` with array destructuring\n     * to ensure multiple documents.\n     * \n     * @param  {Object[]} docs\n     * @return {Promise<Object[]>}\n     */\n    insertMany([...docs]) {\n        return this.insert(docs);\n    }\n\n    /**\n     * Update documents that match the specified `query`.\n     *\n     * It's basically the same as the original:\n     * https://github.com/louischatriot/nedb#updating-documents\n     *\n     * If you set `options.returnUpdatedDocs`,\n     * the returned promise will resolve with\n     * an object (if `options.multi` is `false`) or\n     * with an array of objects.\n     * \n     * @param  {Object} query\n     * @param  {Object} update\n     * @param  {Object} [options]\n     * @return {Promise<number|Object|Object[]>}\n     */\n    async update(query, update, options = {}) {\n        await this.load();\n        try {\n            const { numAffected, affectedDocuments } = await this.__original.updateAsync(query, update, options);\n            const result = options.returnUpdatedDocs ? affectedDocuments : numAffected;\n            this.broadcastSuccess('update', result, query, update, options);\n            return result;\n        } catch (error) {\n            this.broadcastError('update', error, query, update, options);\n            throw error;\n        }\n    }\n\n    /**\n     * Update a single document that matches the specified `query`.\n     *\n     * This is just an alias for `update` with `options.multi` set to `false`.\n     * \n     * @param  {Object} query\n     * @param  {Object} update\n     * @param  {Object} [options]\n     * \n     * @return {Promise<number|Object>}\n     */\n    updateOne(query, update, options = {}) {\n        return this.update(query, update, { ...options, multi: false });\n    }\n\n    /**\n     * Update multiple documents that match the specified `query`.\n     *\n     * This is just an alias for `update` with `options.multi` set to `true`.\n     *\n     * @param  {Object} query\n     * @param  {Object} update\n     * @param  {Object} [options]\n     * \n     * @return {Promise<number|Object[]>}\n     */\n    updateMany(query, update, options = {}) {\n        return this.update(query, update, { ...options, multi: true });\n    }\n\n    /**\n     * Remove documents that match the specified `query`.\n     *\n     * It's basically the same as the original:\n     * https://github.com/louischatriot/nedb#removing-documents\n     * \n     * @param  {Object} [query]\n     * @param  {Object} [options]\n     * @return {Promise<number>}\n     */\n    async remove(query = {}, options = {}) {\n        await this.load();\n        try {\n            const result = await this.__original.removeAsync(query, options);\n            this.broadcastSuccess('remove', result, query, options);\n            return result;\n        } catch (error) {\n            this.broadcastError('remove', error, query, options);\n            throw error;\n        }\n    }\n\n    /**\n     * Remove the first document that matches the specified `query`.\n     *\n     * This is just an alias for `remove` with `options.multi` set to `false`.\n     * \n     * @param  {Object} [query]\n     * @param  {Object} [options]\n     * \n     * @return {Promise<number>}\n     */\n    removeOne(query, options = {}) {\n        return this.remove(query, { ...options, multi: false });\n    }\n\n    /**\n     * Remove all documents that match the specified `query`.\n     *\n     * This is just an alias for `remove` with `options.multi` set to `true`.\n     * \n     * @param  {Object} [query]\n     * @param  {Object} [options]\n     * \n     * @return {Promise<number>}\n     */\n    removeMany(query, options = {}) {\n        return this.remove(query, { ...options, multi: true });\n    }\n\n    /**\n     * Remove the first document that matches the specified `query`.\n     *\n     * This is just an alias for `removeOne`.\n     * \n     * @param  {Object} [query]\n     * @param  {Object} [options]\n     * \n     * @return {Promise<number>}\n     */\n    deleteOne(query, options) {\n        return this.removeOne(query, options);\n    }\n\n    /**\n     * Remove all documents that match the specified `query`.\n     *\n     * This is just an alias for `removeMany`.\n     * \n     * @param  {Object} [query]\n     * @param  {Object} [options]\n     * \n     * @return {Promise<number>}\n     */\n    deleteMany(query, options) {\n        return this.removeMany(query, options);\n    }\n\n    /**\n     * Count documents matching the specified `query`.\n     *\n     * It's basically the same as the original:\n     * https://github.com/louischatriot/nedb#counting-documents\n     *\n     * @example\n     * datastore.count({ ... }).limit(...).then(...)\n     *\n     * @example\n     * // in an async function\n     * await datastore.count({ ... })\n     * // or\n     * await datastore.count({ ... }).sort(...).limit(...)\n     * \n     * @param  {Object} [query]\n     * @return {Cursor}\n     */\n    count(query = {}) {\n        return new Cursor(this, 'count', query);\n    }\n\n    /**\n     * https://github.com/louischatriot/nedb#indexing\n     * \n     * @param  {Object} options\n     * @return {Promise<undefined>}\n     */\n    async ensureIndex(options) {\n        try {\n            const result = await this.__original.ensureIndexAsync(options);\n            this.broadcastSuccess('ensureIndex', result, options);\n            return result;\n        } catch (error) {\n            this.broadcastError('ensureIndex', error, options);\n            throw error;\n        }\n    }\n\n    /**\n     * https://github.com/louischatriot/nedb#indexing\n     * \n     * @param  {string} field\n     * @return {Promise<undefined>}\n     */\n    async removeIndex(field) {\n        try {\n            const result = await this.__original.removeIndexAsync(field);\n            this.broadcastSuccess('removeIndex', result, field);\n            return result;\n        } catch (error) {\n            this.broadcastError('removeIndex', error, field);\n            throw error;\n        }\n    }\n\n    /**\n     * Broadcasts operation success messages.\n     * \n     * @param  {string} op\n     * @param  {*}      result\n     * @param  {...*}   args\n     * \n     * @return {undefined}\n     * @private\n     */\n    broadcastSuccess(op, result, ...args) {\n        this.emit(op, this, result, ...args);\n        return this;\n    }\n\n    /**\n     * Broadcasts operation error messages.\n     * \n     * @param  {string} op\n     * @param  {Error}  error\n     * @param  {...*}   args\n     * \n     * @return {undefined}\n     * @private\n     */\n    broadcastError(op, error, ...args) {\n        this.emit(`${op}Error`, this, error, ...args);\n        this.emit('__error__', this, op, error, ...args);\n        return this;\n    }\n}\n\nmodule.exports = Datastore;\n"],"mappings":"AAAA,MAAMA,YAAY,GAAGC,OAAO,CAAC,QAAQ,CAAC;AACtC,MAAMC,iBAAiB,GAAGD,OAAO,CAAC,gBAAgB,CAAC;AACnD,MAAME,MAAM,GAAGF,OAAO,CAAC,UAAU,CAAC;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMG,SAAS,SAASJ,YAAY,CAAC;EACjC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,OAAOK,MAAMA,CAACC,aAAa,EAAE;IACzB,OAAO,IAAIC,KAAK,CAAC,IAAI,IAAI,CAACD,aAAa,CAAC,EAAE;MACtCE,GAAGA,CAACC,MAAM,EAAEC,GAAG,EAAE;QACb,OAAOD,MAAM,CAACC,GAAG,CAAC,GACZD,MAAM,CAACC,GAAG,CAAC,GACXD,MAAM,CAACE,UAAU,CAACD,GAAG,CAAC;MAChC,CAAC;MAEDE,GAAGA,CAACH,MAAM,EAAEC,GAAG,EAAEG,KAAK,EAAE;QACpB,OAAOC,MAAM,CAACC,SAAS,CAACC,cAAc,CAACC,IAAI,CAACR,MAAM,CAACE,UAAU,EAAED,GAAG,CAAC,GAC5DD,MAAM,CAACE,UAAU,CAACD,GAAG,CAAC,GAAGG,KAAK,GAC9BJ,MAAM,CAACC,GAAG,CAAC,GAAGG,KAAM;MAC/B;IACJ,CAAC,CAAC;EACN;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIK,WAAWA,CAACZ,aAAa,EAAE;IACvB,KAAK,CAAC,CAAC;I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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}