{"ast":null,"code":"const model = require('./model.js');\nconst {\n  callbackify\n} = require('util');\n\n/**\n * Has a callback\n * @callback Cursor~mapFn\n * @param {document[]} res\n * @return {*|Promise<*>}\n */\n\n/**\n * Manage access to data, be it to find, update or remove it.\n *\n * It extends `Promise` so that its methods (which return `this`) are chainable & awaitable.\n * @extends Promise\n */\nclass Cursor {\n  /**\n   * Create a new cursor for this collection.\n   * @param {Datastore} db - The datastore this cursor is bound to\n   * @param {query} query - The query this cursor will operate on\n   * @param {Cursor~mapFn} [mapFn] - Handler to be executed after cursor has found the results and before the callback passed to find/findOne/update/remove\n   */\n  constructor(db, query, mapFn) {\n    /**\n     * @protected\n     * @type {Datastore}\n     */\n    this.db = db;\n    /**\n     * @protected\n     * @type {query}\n     */\n    this.query = query || {};\n    /**\n     * The handler to be executed after cursor has found the results.\n     * @type {Cursor~mapFn}\n     * @protected\n     */\n    if (mapFn) this.mapFn = mapFn;\n    /**\n     * @see Cursor#limit\n     * @type {undefined|number}\n     * @private\n     */\n    this._limit = undefined;\n    /**\n     * @see Cursor#skip\n     * @type {undefined|number}\n     * @private\n     */\n    this._skip = undefined;\n    /**\n     * @see Cursor#sort\n     * @type {undefined|Object.<string, number>}\n     * @private\n     */\n    this._sort = undefined;\n    /**\n     * @see Cursor#projection\n     * @type {undefined|Object.<string, number>}\n     * @private\n     */\n    this._projection = undefined;\n  }\n\n  /**\n   * Set a limit to the number of results for the given Cursor.\n   * @param {Number} limit\n   * @return {Cursor} the same instance of Cursor, (useful for chaining).\n   */\n  limit(limit) {\n    this._limit = limit;\n    return this;\n  }\n\n  /**\n   * Skip a number of results for the given Cursor.\n   * @param {Number} skip\n   * @return {Cursor} the same instance of Cursor, (useful for chaining).\n   */\n  skip(skip) {\n    this._skip = skip;\n    return this;\n  }\n\n  /**\n   * Sort results of the query for the given Cursor.\n   * @param {Object.<string, number>} sortQuery - sortQuery is { field: order }, field can use the dot-notation, order is 1 for ascending and -1 for descending\n   * @return {Cursor} the same instance of Cursor, (useful for chaining).\n   */\n  sort(sortQuery) {\n    this._sort = sortQuery;\n    return this;\n  }\n\n  /**\n   * Add the use of a projection to the given Cursor.\n   * @param {Object.<string, number>} projection - MongoDB-style projection. {} means take all fields. Then it's { key1: 1, key2: 1 } to take only key1 and key2\n   * { key1: 0, key2: 0 } to omit only key1 and key2. Except _id, you can't mix takes and omits.\n   * @return {Cursor} the same instance of Cursor, (useful for chaining).\n   */\n  projection(projection) {\n    this._projection = projection;\n    return this;\n  }\n\n  /**\n   * Apply the projection.\n   *\n   * This is an internal function. You should use {@link Cursor#execAsync} or {@link Cursor#exec}.\n   * @param {document[]} candidates\n   * @return {document[]}\n   * @private\n   */\n  _project(candidates) {\n    const res = [];\n    let action;\n    if (this._projection === undefined || Object.keys(this._projection).length === 0) {\n      return candidates;\n    }\n    const keepId = this._projection._id !== 0;\n    const {\n      _id,\n      ...rest\n    } = this._projection;\n    this._projection = rest;\n\n    // Check for consistency\n    const keys = Object.keys(this._projection);\n    keys.forEach(k => {\n      if (action !== undefined && this._projection[k] !== action) throw new Error('Can\\'t both keep and omit fields except for _id');\n      action = this._projection[k];\n    });\n\n    // Do the actual projection\n    candidates.forEach(candidate => {\n      let toPush;\n      if (action === 1) {\n        // pick-type projection\n        toPush = {\n          $set: {}\n        };\n        keys.forEach(k => {\n          toPush.$set[k] = model.getDotValue(candidate, k);\n          if (toPush.$set[k] === undefined) delete toPush.$set[k];\n        });\n        toPush = model.modify({}, toPush);\n      } else {\n        // omit-type projection\n        toPush = {\n          $unset: {}\n        };\n        keys.forEach(k => {\n          toPush.$unset[k] = true;\n        });\n        toPush = model.modify(candidate, toPush);\n      }\n      if (keepId) toPush._id = candidate._id;else delete toPush._id;\n      res.push(toPush);\n    });\n    return res;\n  }\n\n  /**\n   * Get all matching elements\n   * Will return pointers to matched elements (shallow copies), returning full copies is the role of find or findOne\n   * This is an internal function, use execAsync which uses the executor\n   * @return {document[]|Promise<*>}\n   * @private\n   */\n  async _execAsync() {\n    let res = [];\n    let added = 0;\n    let skipped = 0;\n    const candidates = await this.db._getCandidatesAsync(this.query);\n    for (const candidate of candidates) {\n      if (model.match(candidate, this.query)) {\n        // If a sort is defined, wait for the results to be sorted before applying limit and skip\n        if (!this._sort) {\n          if (this._skip && this._skip > skipped) skipped += 1;else {\n            res.push(candidate);\n            added += 1;\n            if (this._limit && this._limit <= added) break;\n          }\n        } else res.push(candidate);\n      }\n    }\n\n    // Apply all sorts\n    if (this._sort) {\n      // Sorting\n      const criteria = Object.entries(this._sort).map(([key, direction]) => ({\n        key,\n        direction\n      }));\n      res.sort((a, b) => {\n        for (const criterion of criteria) {\n          const compare = criterion.direction * model.compareThings(model.getDotValue(a, criterion.key), model.getDotValue(b, criterion.key), this.db.compareStrings);\n          if (compare !== 0) return compare;\n        }\n        return 0;\n      });\n\n      // Applying limit and skip\n      const limit = this._limit || res.length;\n      const skip = this._skip || 0;\n      res = res.slice(skip, skip + limit);\n    }\n\n    // Apply projection\n    res = this._project(res);\n    if (this.mapFn) return this.mapFn(res);\n    return res;\n  }\n\n  /**\n   * @callback Cursor~execCallback\n   * @param {Error} err\n   * @param {document[]|*} res If a mapFn was given to the Cursor, then the type of this parameter is the one returned by the mapFn.\n   */\n\n  /**\n   * Callback version of {@link Cursor#exec}.\n   * @param {Cursor~execCallback} _callback\n   * @see Cursor#execAsync\n   */\n  exec(_callback) {\n    callbackify(() => this.execAsync())(_callback);\n  }\n\n  /**\n   * Get all matching elements.\n   * Will return pointers to matched elements (shallow copies), returning full copies is the role of {@link Datastore#findAsync} or {@link Datastore#findOneAsync}.\n   * @return {Promise<document[]|*>}\n   * @async\n   */\n  execAsync() {\n    return this.db.executor.pushAsync(() => this._execAsync());\n  }\n  then(onFulfilled, onRejected) {\n    return this.execAsync().then(onFulfilled, onRejected);\n  }\n  catch(onRejected) {\n    return this.execAsync().catch(onRejected);\n  }\n  finally(onFinally) {\n    return this.execAsync().finally(onFinally);\n  }\n}\n\n// Interface\nmodule.exports = Cursor;","map":{"version":3,"names":["model","require","callbackify","Cursor","constructor","db","query","mapFn","_limit","undefined","_skip","_sort","_projection","limit","skip","sort","sortQuery","projection","_project","candidates","res","action","Object","keys","length","keepId","_id","rest","forEach","k","Error","candidate","toPush","$set","getDotValue","modify","$unset","push","_execAsync","added","skipped","_getCandidatesAsync","match","criteria","entries","map","key","direction","a","b","criterion","compare","compareThings","compareStrings","slice","exec","_callback","execAsync","executor","pushAsync","then","onFulfilled","onRejected","catch","finally","onFinally","module","exports"],"sources":["C:/Users/benit/Music/arbisout/node_modules/@seald-io/nedb/lib/cursor.js"],"sourcesContent":["const model = require('./model.js')\nconst { callbackify } = require('util')\n\n/**\n * Has a callback\n * @callback Cursor~mapFn\n * @param {document[]} res\n * @return {*|Promise<*>}\n */\n\n/**\n * Manage access to data, be it to find, update or remove it.\n *\n * It extends `Promise` so that its methods (which return `this`) are chainable & awaitable.\n * @extends Promise\n */\nclass Cursor {\n  /**\n   * Create a new cursor for this collection.\n   * @param {Datastore} db - The datastore this cursor is bound to\n   * @param {query} query - The query this cursor will operate on\n   * @param {Cursor~mapFn} [mapFn] - Handler to be executed after cursor has found the results and before the callback passed to find/findOne/update/remove\n   */\n  constructor (db, query, mapFn) {\n    /**\n     * @protected\n     * @type {Datastore}\n     */\n    this.db = db\n    /**\n     * @protected\n     * @type {query}\n     */\n    this.query = query || {}\n    /**\n     * The handler to be executed after cursor has found the results.\n     * @type {Cursor~mapFn}\n     * @protected\n     */\n    if (mapFn) this.mapFn = mapFn\n    /**\n     * @see Cursor#limit\n     * @type {undefined|number}\n     * @private\n     */\n    this._limit = undefined\n    /**\n     * @see Cursor#skip\n     * @type {undefined|number}\n     * @private\n     */\n    this._skip = undefined\n    /**\n     * @see Cursor#sort\n     * @type {undefined|Object.<string, number>}\n     * @private\n     */\n    this._sort = undefined\n    /**\n     * @see Cursor#projection\n     * @type {undefined|Object.<string, number>}\n     * @private\n     */\n    this._projection = undefined\n  }\n\n  /**\n   * Set a limit to the number of results for the given Cursor.\n   * @param {Number} limit\n   * @return {Cursor} the same instance of Cursor, (useful for chaining).\n   */\n  limit (limit) {\n    this._limit = limit\n    return this\n  }\n\n  /**\n   * Skip a number of results for the given Cursor.\n   * @param {Number} skip\n   * @return {Cursor} the same instance of Cursor, (useful for chaining).\n   */\n  skip (skip) {\n    this._skip = skip\n    return this\n  }\n\n  /**\n   * Sort results of the query for the given Cursor.\n   * @param {Object.<string, number>} sortQuery - sortQuery is { field: order }, field can use the dot-notation, order is 1 for ascending and -1 for descending\n   * @return {Cursor} the same instance of Cursor, (useful for chaining).\n   */\n  sort (sortQuery) {\n    this._sort = sortQuery\n    return this\n  }\n\n  /**\n   * Add the use of a projection to the given Cursor.\n   * @param {Object.<string, number>} projection - MongoDB-style projection. {} means take all fields. Then it's { key1: 1, key2: 1 } to take only key1 and key2\n   * { key1: 0, key2: 0 } to omit only key1 and key2. Except _id, you can't mix takes and omits.\n   * @return {Cursor} the same instance of Cursor, (useful for chaining).\n   */\n  projection (projection) {\n    this._projection = projection\n    return this\n  }\n\n  /**\n   * Apply the projection.\n   *\n   * This is an internal function. You should use {@link Cursor#execAsync} or {@link Cursor#exec}.\n   * @param {document[]} candidates\n   * @return {document[]}\n   * @private\n   */\n  _project (candidates) {\n    const res = []\n    let action\n\n    if (this._projection === undefined || Object.keys(this._projection).length === 0) {\n      return candidates\n    }\n\n    const keepId = this._projection._id !== 0\n    const { _id, ...rest } = this._projection\n    this._projection = rest\n\n    // Check for consistency\n    const keys = Object.keys(this._projection)\n    keys.forEach(k => {\n      if (action !== undefined && this._projection[k] !== action) throw new Error('Can\\'t both keep and omit fields except for _id')\n      action = this._projection[k]\n    })\n\n    // Do the actual projection\n    candidates.forEach(candidate => {\n      let toPush\n      if (action === 1) { // pick-type projection\n        toPush = { $set: {} }\n        keys.forEach(k => {\n          toPush.$set[k] = model.getDotValue(candidate, k)\n          if (toPush.$set[k] === undefined) delete toPush.$set[k]\n        })\n        toPush = model.modify({}, toPush)\n      } else { // omit-type projection\n        toPush = { $unset: {} }\n        keys.forEach(k => { toPush.$unset[k] = true })\n        toPush = model.modify(candidate, toPush)\n      }\n      if (keepId) toPush._id = candidate._id\n      else delete toPush._id\n      res.push(toPush)\n    })\n\n    return res\n  }\n\n  /**\n   * Get all matching elements\n   * Will return pointers to matched elements (shallow copies), returning full copies is the role of find or findOne\n   * This is an internal function, use execAsync which uses the executor\n   * @return {document[]|Promise<*>}\n   * @private\n   */\n  async _execAsync () {\n    let res = []\n    let added = 0\n    let skipped = 0\n\n    const candidates = await this.db._getCandidatesAsync(this.query)\n\n    for (const candidate of candidates) {\n      if (model.match(candidate, this.query)) {\n        // If a sort is defined, wait for the results to be sorted before applying limit and skip\n        if (!this._sort) {\n          if (this._skip && this._skip > skipped) skipped += 1\n          else {\n            res.push(candidate)\n            added += 1\n            if (this._limit && this._limit <= added) break\n          }\n        } else res.push(candidate)\n      }\n    }\n\n    // Apply all sorts\n    if (this._sort) {\n      // Sorting\n      const criteria = Object.entries(this._sort).map(([key, direction]) => ({ key, direction }))\n      res.sort((a, b) => {\n        for (const criterion of criteria) {\n          const compare = criterion.direction * model.compareThings(model.getDotValue(a, criterion.key), model.getDotValue(b, criterion.key), this.db.compareStrings)\n          if (compare !== 0) return compare\n        }\n        return 0\n      })\n\n      // Applying limit and skip\n      const limit = this._limit || res.length\n      const skip = this._skip || 0\n\n      res = res.slice(skip, skip + limit)\n    }\n\n    // Apply projection\n    res = this._project(res)\n    if (this.mapFn) return this.mapFn(res)\n    return res\n  }\n\n  /**\n   * @callback Cursor~execCallback\n   * @param {Error} err\n   * @param {document[]|*} res If a mapFn was given to the Cursor, then the type of this parameter is the one returned by the mapFn.\n   */\n\n  /**\n   * Callback version of {@link Cursor#exec}.\n   * @param {Cursor~execCallback} _callback\n   * @see Cursor#execAsync\n   */\n  exec (_callback) {\n    callbackify(() => this.execAsync())(_callback)\n  }\n\n  /**\n   * Get all matching elements.\n   * Will return pointers to matched elements (shallow copies), returning full copies is the role of {@link Datastore#findAsync} or {@link Datastore#findOneAsync}.\n   * @return {Promise<document[]|*>}\n   * @async\n   */\n  execAsync () {\n    return this.db.executor.pushAsync(() => this._execAsync())\n  }\n\n  then (onFulfilled, onRejected) {\n    return this.execAsync().then(onFulfilled, onRejected)\n  }\n\n  catch (onRejected) {\n    return this.execAsync().catch(onRejected)\n  }\n\n  finally (onFinally) {\n    return this.execAsync().finally(onFinally)\n  }\n}\n\n// Interface\nmodule.exports = Cursor\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}