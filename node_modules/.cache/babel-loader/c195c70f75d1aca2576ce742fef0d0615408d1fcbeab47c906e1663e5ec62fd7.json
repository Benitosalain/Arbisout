{"ast":null,"code":"/**\n * Utility functions that need to be reimplemented for each environment.\n * This is the version for the browser & React-Native\n * @module customUtilsBrowser\n * @private\n */\n\n/**\n * Taken from the crypto-browserify module\n * https://github.com/dominictarr/crypto-browserify\n * NOTE: Math.random() does not guarantee \"cryptographic quality\" but we actually don't need it\n * @param {number} size in bytes\n * @return {Array<number>}\n */\nconst randomBytes = size => {\n  const bytes = new Array(size);\n  for (let i = 0, r; i < size; i++) {\n    if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n    bytes[i] = r >>> ((i & 0x03) << 3) & 0xff;\n  }\n  return bytes;\n};\n\n/**\n * Taken from the base64-js module\n * https://github.com/beatgammit/base64-js/\n * @param {Array} uint8\n * @return {string}\n */\nconst byteArrayToBase64 = uint8 => {\n  const lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n  const extraBytes = uint8.length % 3; // if we have 1 byte left, pad 2 bytes\n  let output = '';\n  let temp;\n  const tripletToBase64 = num => lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (let i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n    temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];\n    output += tripletToBase64(temp);\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    temp = uint8[uint8.length - 1];\n    output += lookup[temp >> 2];\n    output += lookup[temp << 4 & 0x3F];\n    output += '==';\n  } else if (extraBytes === 2) {\n    temp = (uint8[uint8.length - 2] << 8) + uint8[uint8.length - 1];\n    output += lookup[temp >> 10];\n    output += lookup[temp >> 4 & 0x3F];\n    output += lookup[temp << 2 & 0x3F];\n    output += '=';\n  }\n  return output;\n};\n\n/**\n * Return a random alphanumerical string of length len\n * There is a very small probability (less than 1/1,000,000) for the length to be less than len\n * (il the base64 conversion yields too many pluses and slashes) but\n * that's not an issue here\n * The probability of a collision is extremely small (need 3*10^12 documents to have one chance in a million of a collision)\n * See http://en.wikipedia.org/wiki/Birthday_problem\n * @param {number} len\n * @return {string}\n * @alias module:customUtilsNode.uid\n */\nconst uid = len => byteArrayToBase64(randomBytes(Math.ceil(Math.max(8, len * 2)))).replace(/[+/]/g, '').slice(0, len);\nmodule.exports.uid = uid;","map":{"version":3,"names":["randomBytes","size","bytes","Array","i","r","Math","random","byteArrayToBase64","uint8","lookup","extraBytes","length","output","temp","tripletToBase64","num","uid","len","ceil","max","replace","slice","module","exports"],"sources":["C:/Users/benit/Music/arbisout/node_modules/@seald-io/nedb/browser-version/lib/customUtils.js"],"sourcesContent":["/**\n * Utility functions that need to be reimplemented for each environment.\n * This is the version for the browser & React-Native\n * @module customUtilsBrowser\n * @private\n */\n\n/**\n * Taken from the crypto-browserify module\n * https://github.com/dominictarr/crypto-browserify\n * NOTE: Math.random() does not guarantee \"cryptographic quality\" but we actually don't need it\n * @param {number} size in bytes\n * @return {Array<number>}\n */\nconst randomBytes = size => {\n  const bytes = new Array(size)\n\n  for (let i = 0, r; i < size; i++) {\n    if ((i & 0x03) === 0) r = Math.random() * 0x100000000\n    bytes[i] = r >>> ((i & 0x03) << 3) & 0xff\n  }\n\n  return bytes\n}\n\n/**\n * Taken from the base64-js module\n * https://github.com/beatgammit/base64-js/\n * @param {Array} uint8\n * @return {string}\n */\nconst byteArrayToBase64 = uint8 => {\n  const lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n  const extraBytes = uint8.length % 3 // if we have 1 byte left, pad 2 bytes\n  let output = ''\n  let temp\n\n  const tripletToBase64 = num => lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (let i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n    temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n    output += tripletToBase64(temp)\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    temp = uint8[uint8.length - 1]\n    output += lookup[temp >> 2]\n    output += lookup[(temp << 4) & 0x3F]\n    output += '=='\n  } else if (extraBytes === 2) {\n    temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])\n    output += lookup[temp >> 10]\n    output += lookup[(temp >> 4) & 0x3F]\n    output += lookup[(temp << 2) & 0x3F]\n    output += '='\n  }\n\n  return output\n}\n\n/**\n * Return a random alphanumerical string of length len\n * There is a very small probability (less than 1/1,000,000) for the length to be less than len\n * (il the base64 conversion yields too many pluses and slashes) but\n * that's not an issue here\n * The probability of a collision is extremely small (need 3*10^12 documents to have one chance in a million of a collision)\n * See http://en.wikipedia.org/wiki/Birthday_problem\n * @param {number} len\n * @return {string}\n * @alias module:customUtilsNode.uid\n */\nconst uid = len => byteArrayToBase64(randomBytes(Math.ceil(Math.max(8, len * 2)))).replace(/[+/]/g, '').slice(0, len)\n\nmodule.exports.uid = uid\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}