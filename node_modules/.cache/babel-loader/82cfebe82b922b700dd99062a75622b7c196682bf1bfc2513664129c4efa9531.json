{"ast":null,"code":"/**\n * Self-balancing binary search tree using the AVL implementation\n */\nconst BinarySearchTree = require('./bst');\nconst customUtils = require('./customUtils');\nclass AVLTree {\n  /**\n   * Constructor\n   * We can't use a direct pointer to the root node (as in the simple binary search tree)\n   * as the root will change during tree rotations\n   * @param {Boolean}  options.unique Whether to enforce a 'unique' constraint on the key or not\n   * @param {Function} options.compareKeys Initialize this BST's compareKeys\n   */\n  constructor(options) {\n    this.tree = new _AVLTree(options);\n  }\n  checkIsAVLT() {\n    this.tree.checkIsAVLT();\n  }\n\n  // Insert in the internal tree, update the pointer to the root if needed\n  insert(key, value) {\n    const newTree = this.tree.insert(key, value);\n\n    // If newTree is undefined, that means its structure was not modified\n    if (newTree) {\n      this.tree = newTree;\n    }\n  }\n\n  // Delete a value\n  delete(key, value) {\n    const newTree = this.tree.delete(key, value);\n\n    // If newTree is undefined, that means its structure was not modified\n    if (newTree) {\n      this.tree = newTree;\n    }\n  }\n}\nclass _AVLTree extends BinarySearchTree {\n  /**\n   * Constructor of the internal AVLTree\n   * @param {Object} options Optional\n   * @param {Boolean}  options.unique Whether to enforce a 'unique' constraint on the key or not\n   * @param {Key}      options.key Initialize this BST's key with key\n   * @param {Value}    options.value Initialize this BST's data with [value]\n   * @param {Function} options.compareKeys Initialize this BST's compareKeys\n   */\n  constructor(options) {\n    super();\n    options = options || {};\n    this.left = null;\n    this.right = null;\n    this.parent = options.parent !== undefined ? options.parent : null;\n    if (Object.prototype.hasOwnProperty.call(options, 'key')) this.key = options.key;\n    this.data = Object.prototype.hasOwnProperty.call(options, 'value') ? [options.value] : [];\n    this.unique = options.unique || false;\n    this.compareKeys = options.compareKeys || customUtils.defaultCompareKeysFunction;\n    this.checkValueEquality = options.checkValueEquality || customUtils.defaultCheckValueEquality;\n  }\n\n  /**\n   * Check the recorded height is correct for every node\n   * Throws if one height doesn't match\n   */\n  checkHeightCorrect() {\n    if (!Object.prototype.hasOwnProperty.call(this, 'key')) {\n      return;\n    } // Empty tree\n\n    if (this.left && this.left.height === undefined) {\n      throw new Error('Undefined height for node ' + this.left.key);\n    }\n    if (this.right && this.right.height === undefined) {\n      throw new Error('Undefined height for node ' + this.right.key);\n    }\n    if (this.height === undefined) {\n      throw new Error('Undefined height for node ' + this.key);\n    }\n    const leftH = this.left ? this.left.height : 0;\n    const rightH = this.right ? this.right.height : 0;\n    if (this.height !== 1 + Math.max(leftH, rightH)) {\n      throw new Error('Height constraint failed for node ' + this.key);\n    }\n    if (this.left) {\n      this.left.checkHeightCorrect();\n    }\n    if (this.right) {\n      this.right.checkHeightCorrect();\n    }\n  }\n\n  /**\n   * Return the balance factor\n   */\n  balanceFactor() {\n    const leftH = this.left ? this.left.height : 0;\n    const rightH = this.right ? this.right.height : 0;\n    return leftH - rightH;\n  }\n\n  /**\n   * Check that the balance factors are all between -1 and 1\n   */\n  checkBalanceFactors() {\n    if (Math.abs(this.balanceFactor()) > 1) {\n      throw new Error('Tree is unbalanced at node ' + this.key);\n    }\n    if (this.left) {\n      this.left.checkBalanceFactors();\n    }\n    if (this.right) {\n      this.right.checkBalanceFactors();\n    }\n  }\n\n  /**\n   * When checking if the BST conditions are met, also check that the heights are correct\n   * and the tree is balanced\n   */\n  checkIsAVLT() {\n    super.checkIsBST();\n    this.checkHeightCorrect();\n    this.checkBalanceFactors();\n  }\n\n  /**\n   * Perform a right rotation of the tree if possible\n   * and return the root of the resulting tree\n   * The resulting tree's nodes' heights are also updated\n   */\n  rightRotation() {\n    const q = this;\n    const p = this.left;\n    if (!p) return q; // No change\n\n    const b = p.right;\n\n    // Alter tree structure\n    if (q.parent) {\n      p.parent = q.parent;\n      if (q.parent.left === q) q.parent.left = p;else q.parent.right = p;\n    } else {\n      p.parent = null;\n    }\n    p.right = q;\n    q.parent = p;\n    q.left = b;\n    if (b) {\n      b.parent = q;\n    }\n\n    // Update heights\n    const ah = p.left ? p.left.height : 0;\n    const bh = b ? b.height : 0;\n    const ch = q.right ? q.right.height : 0;\n    q.height = Math.max(bh, ch) + 1;\n    p.height = Math.max(ah, q.height) + 1;\n    return p;\n  }\n\n  /**\n   * Perform a left rotation of the tree if possible\n   * and return the root of the resulting tree\n   * The resulting tree's nodes' heights are also updated\n   */\n  leftRotation() {\n    const p = this;\n    const q = this.right;\n    if (!q) {\n      return this;\n    } // No change\n\n    const b = q.left;\n\n    // Alter tree structure\n    if (p.parent) {\n      q.parent = p.parent;\n      if (p.parent.left === p) p.parent.left = q;else p.parent.right = q;\n    } else {\n      q.parent = null;\n    }\n    q.left = p;\n    p.parent = q;\n    p.right = b;\n    if (b) {\n      b.parent = p;\n    }\n\n    // Update heights\n    const ah = p.left ? p.left.height : 0;\n    const bh = b ? b.height : 0;\n    const ch = q.right ? q.right.height : 0;\n    p.height = Math.max(ah, bh) + 1;\n    q.height = Math.max(ch, p.height) + 1;\n    return q;\n  }\n\n  /**\n   * Modify the tree if its right subtree is too small compared to the left\n   * Return the new root if any\n   */\n  rightTooSmall() {\n    if (this.balanceFactor() <= 1) return this; // Right is not too small, don't change\n\n    if (this.left.balanceFactor() < 0) this.left.leftRotation();\n    return this.rightRotation();\n  }\n\n  /**\n   * Modify the tree if its left subtree is too small compared to the right\n   * Return the new root if any\n   */\n  leftTooSmall() {\n    if (this.balanceFactor() >= -1) {\n      return this;\n    } // Left is not too small, don't change\n\n    if (this.right.balanceFactor() > 0) this.right.rightRotation();\n    return this.leftRotation();\n  }\n\n  /**\n   * Rebalance the tree along the given path. The path is given reversed (as he was calculated\n   * in the insert and delete functions).\n   * Returns the new root of the tree\n   * Of course, the first element of the path must be the root of the tree\n   */\n  rebalanceAlongPath(path) {\n    let newRoot = this;\n    let rotated;\n    let i;\n    if (!Object.prototype.hasOwnProperty.call(this, 'key')) {\n      delete this.height;\n      return this;\n    } // Empty tree\n\n    // Rebalance the tree and update all heights\n    for (i = path.length - 1; i >= 0; i -= 1) {\n      path[i].height = 1 + Math.max(path[i].left ? path[i].left.height : 0, path[i].right ? path[i].right.height : 0);\n      if (path[i].balanceFactor() > 1) {\n        rotated = path[i].rightTooSmall();\n        if (i === 0) newRoot = rotated;\n      }\n      if (path[i].balanceFactor() < -1) {\n        rotated = path[i].leftTooSmall();\n        if (i === 0) newRoot = rotated;\n      }\n    }\n    return newRoot;\n  }\n\n  /**\n   * Insert a key, value pair in the tree while maintaining the AVL tree height constraint\n   * Return a pointer to the root node, which may have changed\n   */\n  insert(key, value) {\n    const insertPath = [];\n    let currentNode = this;\n\n    // Empty tree, insert as root\n    if (!Object.prototype.hasOwnProperty.call(this, 'key')) {\n      this.key = key;\n      this.data.push(value);\n      this.height = 1;\n      return this;\n    }\n\n    // Insert new leaf at the right place\n    while (true) {\n      // Same key: no change in the tree structure\n      if (currentNode.compareKeys(currentNode.key, key) === 0) {\n        if (currentNode.unique) {\n          const err = new Error(`Can't insert key ${JSON.stringify(key)}, it violates the unique constraint`);\n          err.key = key;\n          err.errorType = 'uniqueViolated';\n          throw err;\n        } else currentNode.data.push(value);\n        return this;\n      }\n      insertPath.push(currentNode);\n      if (currentNode.compareKeys(key, currentNode.key) < 0) {\n        if (!currentNode.left) {\n          insertPath.push(currentNode.createLeftChild({\n            key: key,\n            value: value\n          }));\n          break;\n        } else currentNode = currentNode.left;\n      } else {\n        if (!currentNode.right) {\n          insertPath.push(currentNode.createRightChild({\n            key: key,\n            value: value\n          }));\n          break;\n        } else currentNode = currentNode.right;\n      }\n    }\n    return this.rebalanceAlongPath(insertPath);\n  }\n\n  /**\n   * Delete a key or just a value and return the new root of the tree\n   * @param {Key} key\n   * @param {Value} value Optional. If not set, the whole key is deleted. If set, only this value is deleted\n   */\n  delete(key, value) {\n    const newData = [];\n    let replaceWith;\n    let currentNode = this;\n    const deletePath = [];\n    if (!Object.prototype.hasOwnProperty.call(this, 'key')) return this; // Empty tree\n\n    // Either no match is found and the function will return from within the loop\n    // Or a match is found and deletePath will contain the path from the root to the node to delete after the loop\n    while (true) {\n      if (currentNode.compareKeys(key, currentNode.key) === 0) {\n        break;\n      }\n      deletePath.push(currentNode);\n      if (currentNode.compareKeys(key, currentNode.key) < 0) {\n        if (currentNode.left) {\n          currentNode = currentNode.left;\n        } else return this; // Key not found, no modification\n      } else {\n        // currentNode.compareKeys(key, currentNode.key) is > 0\n        if (currentNode.right) {\n          currentNode = currentNode.right;\n        } else return this; // Key not found, no modification\n      }\n    }\n\n    // Delete only a value (no tree modification)\n    if (currentNode.data.length > 1 && value !== undefined) {\n      currentNode.data.forEach(function (d) {\n        if (!currentNode.checkValueEquality(d, value)) newData.push(d);\n      });\n      currentNode.data = newData;\n      return this;\n    }\n\n    // Delete a whole node\n\n    // Leaf\n    if (!currentNode.left && !currentNode.right) {\n      if (currentNode === this) {\n        // This leaf is also the root\n        delete currentNode.key;\n        currentNode.data = [];\n        delete currentNode.height;\n        return this;\n      } else {\n        if (currentNode.parent.left === currentNode) currentNode.parent.left = null;else currentNode.parent.right = null;\n        return this.rebalanceAlongPath(deletePath);\n      }\n    }\n\n    // Node with only one child\n    if (!currentNode.left || !currentNode.right) {\n      replaceWith = currentNode.left ? currentNode.left : currentNode.right;\n      if (currentNode === this) {\n        // This node is also the root\n        replaceWith.parent = null;\n        return replaceWith; // height of replaceWith is necessarily 1 because the tree was balanced before deletion\n      } else {\n        if (currentNode.parent.left === currentNode) {\n          currentNode.parent.left = replaceWith;\n          replaceWith.parent = currentNode.parent;\n        } else {\n          currentNode.parent.right = replaceWith;\n          replaceWith.parent = currentNode.parent;\n        }\n        return this.rebalanceAlongPath(deletePath);\n      }\n    }\n\n    // Node with two children\n    // Use the in-order predecessor (no need to randomize since we actively rebalance)\n    deletePath.push(currentNode);\n    replaceWith = currentNode.left;\n\n    // Special case: the in-order predecessor is right below the node to delete\n    if (!replaceWith.right) {\n      currentNode.key = replaceWith.key;\n      currentNode.data = replaceWith.data;\n      currentNode.left = replaceWith.left;\n      if (replaceWith.left) {\n        replaceWith.left.parent = currentNode;\n      }\n      return this.rebalanceAlongPath(deletePath);\n    }\n\n    // After this loop, replaceWith is the right-most leaf in the left subtree\n    // and deletePath the path from the root (inclusive) to replaceWith (exclusive)\n    while (true) {\n      if (replaceWith.right) {\n        deletePath.push(replaceWith);\n        replaceWith = replaceWith.right;\n      } else break;\n    }\n    currentNode.key = replaceWith.key;\n    currentNode.data = replaceWith.data;\n    replaceWith.parent.right = replaceWith.left;\n    if (replaceWith.left) replaceWith.left.parent = replaceWith.parent;\n    return this.rebalanceAlongPath(deletePath);\n  }\n}\n\n/**\n * Keep a pointer to the internal tree constructor for testing purposes\n */\nAVLTree._AVLTree = _AVLTree;\n\n/**\n * Other functions we want to use on an AVLTree as if it were the internal _AVLTree\n */\n['getNumberOfKeys', 'search', 'betweenBounds', 'prettyPrint', 'executeOnEveryNode'].forEach(function (fn) {\n  AVLTree.prototype[fn] = function () {\n    return this.tree[fn].apply(this.tree, arguments);\n  };\n});\n\n// Interface\nmodule.exports = AVLTree;","map":{"version":3,"names":["BinarySearchTree","require","customUtils","AVLTree","constructor","options","tree","_AVLTree","checkIsAVLT","insert","key","value","newTree","delete","left","right","parent","undefined","Object","prototype","hasOwnProperty","call","data","unique","compareKeys","defaultCompareKeysFunction","checkValueEquality","defaultCheckValueEquality","checkHeightCorrect","height","Error","leftH","rightH","Math","max","balanceFactor","checkBalanceFactors","abs","checkIsBST","rightRotation","q","p","b","ah","bh","ch","leftRotation","rightTooSmall","leftTooSmall","rebalanceAlongPath","path","newRoot","rotated","i","length","insertPath","currentNode","push","err","JSON","stringify","errorType","createLeftChild","createRightChild","newData","replaceWith","deletePath","forEach","d","fn","apply","arguments","module","exports"],"sources":["C:/Users/benit/Music/arbisout/node_modules/@seald-io/binary-search-tree/lib/avltree.js"],"sourcesContent":["/**\n * Self-balancing binary search tree using the AVL implementation\n */\nconst BinarySearchTree = require('./bst')\nconst customUtils = require('./customUtils')\n\nclass AVLTree {\n  /**\n   * Constructor\n   * We can't use a direct pointer to the root node (as in the simple binary search tree)\n   * as the root will change during tree rotations\n   * @param {Boolean}  options.unique Whether to enforce a 'unique' constraint on the key or not\n   * @param {Function} options.compareKeys Initialize this BST's compareKeys\n   */\n  constructor (options) {\n    this.tree = new _AVLTree(options)\n  }\n\n  checkIsAVLT () { this.tree.checkIsAVLT() }\n\n  // Insert in the internal tree, update the pointer to the root if needed\n  insert (key, value) {\n    const newTree = this.tree.insert(key, value)\n\n    // If newTree is undefined, that means its structure was not modified\n    if (newTree) { this.tree = newTree }\n  }\n\n  // Delete a value\n  delete (key, value) {\n    const newTree = this.tree.delete(key, value)\n\n    // If newTree is undefined, that means its structure was not modified\n    if (newTree) { this.tree = newTree }\n  }\n}\n\nclass _AVLTree extends BinarySearchTree {\n  /**\n   * Constructor of the internal AVLTree\n   * @param {Object} options Optional\n   * @param {Boolean}  options.unique Whether to enforce a 'unique' constraint on the key or not\n   * @param {Key}      options.key Initialize this BST's key with key\n   * @param {Value}    options.value Initialize this BST's data with [value]\n   * @param {Function} options.compareKeys Initialize this BST's compareKeys\n   */\n  constructor (options) {\n    super()\n    options = options || {}\n\n    this.left = null\n    this.right = null\n    this.parent = options.parent !== undefined ? options.parent : null\n    if (Object.prototype.hasOwnProperty.call(options, 'key')) this.key = options.key\n    this.data = Object.prototype.hasOwnProperty.call(options, 'value') ? [options.value] : []\n    this.unique = options.unique || false\n\n    this.compareKeys = options.compareKeys || customUtils.defaultCompareKeysFunction\n    this.checkValueEquality = options.checkValueEquality || customUtils.defaultCheckValueEquality\n  }\n\n  /**\n   * Check the recorded height is correct for every node\n   * Throws if one height doesn't match\n   */\n  checkHeightCorrect () {\n    if (!Object.prototype.hasOwnProperty.call(this, 'key')) { return } // Empty tree\n\n    if (this.left && this.left.height === undefined) { throw new Error('Undefined height for node ' + this.left.key) }\n    if (this.right && this.right.height === undefined) { throw new Error('Undefined height for node ' + this.right.key) }\n    if (this.height === undefined) { throw new Error('Undefined height for node ' + this.key) }\n\n    const leftH = this.left ? this.left.height : 0\n    const rightH = this.right ? this.right.height : 0\n\n    if (this.height !== 1 + Math.max(leftH, rightH)) { throw new Error('Height constraint failed for node ' + this.key) }\n    if (this.left) { this.left.checkHeightCorrect() }\n    if (this.right) { this.right.checkHeightCorrect() }\n  }\n\n  /**\n   * Return the balance factor\n   */\n  balanceFactor () {\n    const leftH = this.left ? this.left.height : 0\n    const rightH = this.right ? this.right.height : 0\n    return leftH - rightH\n  }\n\n  /**\n   * Check that the balance factors are all between -1 and 1\n   */\n  checkBalanceFactors () {\n    if (Math.abs(this.balanceFactor()) > 1) { throw new Error('Tree is unbalanced at node ' + this.key) }\n\n    if (this.left) { this.left.checkBalanceFactors() }\n    if (this.right) { this.right.checkBalanceFactors() }\n  }\n\n  /**\n   * When checking if the BST conditions are met, also check that the heights are correct\n   * and the tree is balanced\n   */\n  checkIsAVLT () {\n    super.checkIsBST()\n    this.checkHeightCorrect()\n    this.checkBalanceFactors()\n  }\n\n  /**\n   * Perform a right rotation of the tree if possible\n   * and return the root of the resulting tree\n   * The resulting tree's nodes' heights are also updated\n   */\n  rightRotation () {\n    const q = this\n    const p = this.left\n\n    if (!p) return q // No change\n\n    const b = p.right\n\n    // Alter tree structure\n    if (q.parent) {\n      p.parent = q.parent\n      if (q.parent.left === q) q.parent.left = p\n      else q.parent.right = p\n    } else {\n      p.parent = null\n    }\n    p.right = q\n    q.parent = p\n    q.left = b\n    if (b) { b.parent = q }\n\n    // Update heights\n    const ah = p.left ? p.left.height : 0\n    const bh = b ? b.height : 0\n    const ch = q.right ? q.right.height : 0\n    q.height = Math.max(bh, ch) + 1\n    p.height = Math.max(ah, q.height) + 1\n\n    return p\n  }\n\n  /**\n   * Perform a left rotation of the tree if possible\n   * and return the root of the resulting tree\n   * The resulting tree's nodes' heights are also updated\n   */\n  leftRotation () {\n    const p = this\n    const q = this.right\n\n    if (!q) { return this } // No change\n\n    const b = q.left\n\n    // Alter tree structure\n    if (p.parent) {\n      q.parent = p.parent\n      if (p.parent.left === p) p.parent.left = q\n      else p.parent.right = q\n    } else {\n      q.parent = null\n    }\n    q.left = p\n    p.parent = q\n    p.right = b\n    if (b) { b.parent = p }\n\n    // Update heights\n    const ah = p.left ? p.left.height : 0\n    const bh = b ? b.height : 0\n    const ch = q.right ? q.right.height : 0\n    p.height = Math.max(ah, bh) + 1\n    q.height = Math.max(ch, p.height) + 1\n\n    return q\n  }\n\n  /**\n   * Modify the tree if its right subtree is too small compared to the left\n   * Return the new root if any\n   */\n  rightTooSmall () {\n    if (this.balanceFactor() <= 1) return this // Right is not too small, don't change\n\n    if (this.left.balanceFactor() < 0) this.left.leftRotation()\n\n    return this.rightRotation()\n  }\n\n  /**\n   * Modify the tree if its left subtree is too small compared to the right\n   * Return the new root if any\n   */\n  leftTooSmall () {\n    if (this.balanceFactor() >= -1) { return this } // Left is not too small, don't change\n\n    if (this.right.balanceFactor() > 0) this.right.rightRotation()\n\n    return this.leftRotation()\n  }\n\n  /**\n   * Rebalance the tree along the given path. The path is given reversed (as he was calculated\n   * in the insert and delete functions).\n   * Returns the new root of the tree\n   * Of course, the first element of the path must be the root of the tree\n   */\n  rebalanceAlongPath (path) {\n    let newRoot = this\n    let rotated\n    let i\n\n    if (!Object.prototype.hasOwnProperty.call(this, 'key')) {\n      delete this.height\n      return this\n    } // Empty tree\n\n    // Rebalance the tree and update all heights\n    for (i = path.length - 1; i >= 0; i -= 1) {\n      path[i].height = 1 + Math.max(path[i].left ? path[i].left.height : 0, path[i].right ? path[i].right.height : 0)\n\n      if (path[i].balanceFactor() > 1) {\n        rotated = path[i].rightTooSmall()\n        if (i === 0) newRoot = rotated\n      }\n\n      if (path[i].balanceFactor() < -1) {\n        rotated = path[i].leftTooSmall()\n        if (i === 0) newRoot = rotated\n      }\n    }\n\n    return newRoot\n  }\n\n  /**\n   * Insert a key, value pair in the tree while maintaining the AVL tree height constraint\n   * Return a pointer to the root node, which may have changed\n   */\n  insert (key, value) {\n    const insertPath = []\n    let currentNode = this\n\n    // Empty tree, insert as root\n    if (!Object.prototype.hasOwnProperty.call(this, 'key')) {\n      this.key = key\n      this.data.push(value)\n      this.height = 1\n      return this\n    }\n\n    // Insert new leaf at the right place\n    while (true) {\n      // Same key: no change in the tree structure\n      if (currentNode.compareKeys(currentNode.key, key) === 0) {\n        if (currentNode.unique) {\n          const err = new Error(`Can't insert key ${JSON.stringify(key)}, it violates the unique constraint`)\n          err.key = key\n          err.errorType = 'uniqueViolated'\n          throw err\n        } else currentNode.data.push(value)\n        return this\n      }\n\n      insertPath.push(currentNode)\n\n      if (currentNode.compareKeys(key, currentNode.key) < 0) {\n        if (!currentNode.left) {\n          insertPath.push(currentNode.createLeftChild({ key: key, value: value }))\n          break\n        } else currentNode = currentNode.left\n      } else {\n        if (!currentNode.right) {\n          insertPath.push(currentNode.createRightChild({ key: key, value: value }))\n          break\n        } else currentNode = currentNode.right\n      }\n    }\n\n    return this.rebalanceAlongPath(insertPath)\n  }\n\n  /**\n   * Delete a key or just a value and return the new root of the tree\n   * @param {Key} key\n   * @param {Value} value Optional. If not set, the whole key is deleted. If set, only this value is deleted\n   */\n  delete (key, value) {\n    const newData = []\n    let replaceWith\n    let currentNode = this\n    const deletePath = []\n\n    if (!Object.prototype.hasOwnProperty.call(this, 'key')) return this // Empty tree\n\n    // Either no match is found and the function will return from within the loop\n    // Or a match is found and deletePath will contain the path from the root to the node to delete after the loop\n    while (true) {\n      if (currentNode.compareKeys(key, currentNode.key) === 0) { break }\n\n      deletePath.push(currentNode)\n\n      if (currentNode.compareKeys(key, currentNode.key) < 0) {\n        if (currentNode.left) {\n          currentNode = currentNode.left\n        } else return this // Key not found, no modification\n      } else {\n        // currentNode.compareKeys(key, currentNode.key) is > 0\n        if (currentNode.right) {\n          currentNode = currentNode.right\n        } else return this // Key not found, no modification\n      }\n    }\n\n    // Delete only a value (no tree modification)\n    if (currentNode.data.length > 1 && value !== undefined) {\n      currentNode.data.forEach(function (d) {\n        if (!currentNode.checkValueEquality(d, value)) newData.push(d)\n      })\n      currentNode.data = newData\n      return this\n    }\n\n    // Delete a whole node\n\n    // Leaf\n    if (!currentNode.left && !currentNode.right) {\n      if (currentNode === this) { // This leaf is also the root\n        delete currentNode.key\n        currentNode.data = []\n        delete currentNode.height\n        return this\n      } else {\n        if (currentNode.parent.left === currentNode) currentNode.parent.left = null\n        else currentNode.parent.right = null\n        return this.rebalanceAlongPath(deletePath)\n      }\n    }\n\n    // Node with only one child\n    if (!currentNode.left || !currentNode.right) {\n      replaceWith = currentNode.left ? currentNode.left : currentNode.right\n\n      if (currentNode === this) { // This node is also the root\n        replaceWith.parent = null\n        return replaceWith // height of replaceWith is necessarily 1 because the tree was balanced before deletion\n      } else {\n        if (currentNode.parent.left === currentNode) {\n          currentNode.parent.left = replaceWith\n          replaceWith.parent = currentNode.parent\n        } else {\n          currentNode.parent.right = replaceWith\n          replaceWith.parent = currentNode.parent\n        }\n\n        return this.rebalanceAlongPath(deletePath)\n      }\n    }\n\n    // Node with two children\n    // Use the in-order predecessor (no need to randomize since we actively rebalance)\n    deletePath.push(currentNode)\n    replaceWith = currentNode.left\n\n    // Special case: the in-order predecessor is right below the node to delete\n    if (!replaceWith.right) {\n      currentNode.key = replaceWith.key\n      currentNode.data = replaceWith.data\n      currentNode.left = replaceWith.left\n      if (replaceWith.left) { replaceWith.left.parent = currentNode }\n      return this.rebalanceAlongPath(deletePath)\n    }\n\n    // After this loop, replaceWith is the right-most leaf in the left subtree\n    // and deletePath the path from the root (inclusive) to replaceWith (exclusive)\n    while (true) {\n      if (replaceWith.right) {\n        deletePath.push(replaceWith)\n        replaceWith = replaceWith.right\n      } else break\n    }\n\n    currentNode.key = replaceWith.key\n    currentNode.data = replaceWith.data\n\n    replaceWith.parent.right = replaceWith.left\n    if (replaceWith.left) replaceWith.left.parent = replaceWith.parent\n\n    return this.rebalanceAlongPath(deletePath)\n  }\n}\n\n/**\n * Keep a pointer to the internal tree constructor for testing purposes\n */\nAVLTree._AVLTree = _AVLTree;\n\n/**\n * Other functions we want to use on an AVLTree as if it were the internal _AVLTree\n */\n['getNumberOfKeys', 'search', 'betweenBounds', 'prettyPrint', 'executeOnEveryNode'].forEach(function (fn) {\n  AVLTree.prototype[fn] = function () {\n    return this.tree[fn].apply(this.tree, arguments)\n  }\n})\n\n// Interface\nmodule.exports = AVLTree\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}