{"ast":null,"code":"/**\n * Handle models (i.e. docs)\n * Serialization/deserialization\n * Copying\n * Querying, update\n * @module model\n * @private\n */\nconst {\n  uniq,\n  isDate,\n  isRegExp\n} = require('./utils.js');\n\n/**\n * Check a key, throw an error if the key is non valid\n * @param {string} k key\n * @param {document} v value, needed to treat the Date edge case\n * Non-treatable edge cases here: if part of the object if of the form { $$date: number } or { $$deleted: true }\n * Its serialized-then-deserialized version it will transformed into a Date object\n * But you really need to want it to trigger such behaviour, even when warned not to use '$' at the beginning of the field names...\n * @private\n */\nconst checkKey = (k, v) => {\n  if (typeof k === 'number') k = k.toString();\n  if (k[0] === '$' && !(k === '$$date' && typeof v === 'number') && !(k === '$$deleted' && v === true) && !(k === '$$indexCreated') && !(k === '$$indexRemoved')) throw new Error('Field names cannot begin with the $ character');\n  if (k.indexOf('.') !== -1) throw new Error('Field names cannot contain a .');\n};\n\n/**\n * Check a DB object and throw an error if it's not valid\n * Works by applying the above checkKey function to all fields recursively\n * @param {document|document[]} obj\n * @alias module:model.checkObject\n */\nconst checkObject = obj => {\n  if (Array.isArray(obj)) {\n    obj.forEach(o => {\n      checkObject(o);\n    });\n  }\n  if (typeof obj === 'object' && obj !== null) {\n    for (const k in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, k)) {\n        checkKey(k, obj[k]);\n        checkObject(obj[k]);\n      }\n    }\n  }\n};\n\n/**\n * Serialize an object to be persisted to a one-line string\n * For serialization/deserialization, we use the native JSON parser and not eval or Function\n * That gives us less freedom but data entered in the database may come from users\n * so eval and the like are not safe\n * Accepted primitive types: Number, String, Boolean, Date, null\n * Accepted secondary types: Objects, Arrays\n * @param {document} obj\n * @return {string}\n * @alias module:model.serialize\n */\nconst serialize = obj => {\n  return JSON.stringify(obj, function (k, v) {\n    checkKey(k, v);\n    if (v === undefined) return undefined;\n    if (v === null) return null;\n\n    // Hackish way of checking if object is Date (this way it works between execution contexts in node-webkit).\n    // We can't use value directly because for dates it is already string in this function (date.toJSON was already called), so we use this\n    if (typeof this[k].getTime === 'function') return {\n      $$date: this[k].getTime()\n    };\n    return v;\n  });\n};\n\n/**\n * From a one-line representation of an object generate by the serialize function\n * Return the object itself\n * @param {string} rawData\n * @return {document}\n * @alias module:model.deserialize\n */\nconst deserialize = rawData => JSON.parse(rawData, function (k, v) {\n  if (k === '$$date') return new Date(v);\n  if (typeof v === 'string' || typeof v === 'number' || typeof v === 'boolean' || v === null) return v;\n  if (v && v.$$date) return v.$$date;\n  return v;\n});\n\n/**\n * Deep copy a DB object\n * The optional strictKeys flag (defaulting to false) indicates whether to copy everything or only fields\n * where the keys are valid, i.e. don't begin with $ and don't contain a .\n * @param {?document} obj\n * @param {boolean} [strictKeys=false]\n * @return {?document}\n * @alias module:modelel:(.*)\n */\nfunction deepCopy(obj, strictKeys) {\n  if (typeof obj === 'boolean' || typeof obj === 'number' || typeof obj === 'string' || obj === null || isDate(obj)) return obj;\n  if (Array.isArray(obj)) return obj.map(o => deepCopy(o, strictKeys));\n  if (typeof obj === 'object') {\n    const res = {};\n    for (const k in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, k) && (!strictKeys || k[0] !== '$' && k.indexOf('.') === -1)) {\n        res[k] = deepCopy(obj[k], strictKeys);\n      }\n    }\n    return res;\n  }\n  return undefined; // For now everything else is undefined. We should probably throw an error instead\n}\n\n/**\n * Tells if an object is a primitive type or a \"real\" object\n * Arrays are considered primitive\n * @param {*} obj\n * @return {boolean}\n * @alias module:modelel:(.*)\n */\nconst isPrimitiveType = obj => typeof obj === 'boolean' || typeof obj === 'number' || typeof obj === 'string' || obj === null || isDate(obj) || Array.isArray(obj);\n\n/**\n * Utility functions for comparing things\n * Assumes type checking was already done (a and b already have the same type)\n * compareNSB works for numbers, strings and booleans\n * @param {number|string|boolean} a\n * @param {number|string|boolean} b\n * @return {number} 0 if a == b, 1 i a > b, -1 if a < b\n * @private\n */\nconst compareNSB = (a, b) => {\n  if (a < b) return -1;\n  if (a > b) return 1;\n  return 0;\n};\n\n/**\n * Utility function for comparing array\n * Assumes type checking was already done (a and b already have the same type)\n * compareNSB works for numbers, strings and booleans\n * @param {Array} a\n * @param {Array} b\n * @return {number} 0 if arrays have the same length and all elements equal one another. Else either 1 or -1.\n * @private\n */\nconst compareArrays = (a, b) => {\n  const minLength = Math.min(a.length, b.length);\n  for (let i = 0; i < minLength; i += 1) {\n    const comp = compareThings(a[i], b[i]);\n    if (comp !== 0) return comp;\n  }\n\n  // Common section was identical, longest one wins\n  return compareNSB(a.length, b.length);\n};\n\n/**\n * Compare { things U undefined }\n * Things are defined as any native types (string, number, boolean, null, date) and objects\n * We need to compare with undefined as it will be used in indexes\n * In the case of objects and arrays, we deep-compare\n * If two objects dont have the same type, the (arbitrary) type hierarchy is: undefined, null, number, strings, boolean, dates, arrays, objects\n * Return -1 if a < b, 1 if a > b and 0 if a = b (note that equality here is NOT the same as defined in areThingsEqual!)\n * @param {*} a\n * @param {*} b\n * @param {compareStrings} [_compareStrings] String comparing function, returning -1, 0 or 1, overriding default string comparison (useful for languages with accented letters)\n * @return {number}\n * @alias module:model.compareThings\n */\nconst compareThings = (a, b, _compareStrings) => {\n  const compareStrings = _compareStrings || compareNSB;\n\n  // undefined\n  if (a === undefined) return b === undefined ? 0 : -1;\n  if (b === undefined) return 1; // no need to test if a === undefined\n\n  // null\n  if (a === null) return b === null ? 0 : -1;\n  if (b === null) return 1; // no need to test if a === null\n\n  // Numbers\n  if (typeof a === 'number') return typeof b === 'number' ? compareNSB(a, b) : -1;\n  if (typeof b === 'number') return typeof a === 'number' ? compareNSB(a, b) : 1;\n\n  // Strings\n  if (typeof a === 'string') return typeof b === 'string' ? compareStrings(a, b) : -1;\n  if (typeof b === 'string') return typeof a === 'string' ? compareStrings(a, b) : 1;\n\n  // Booleans\n  if (typeof a === 'boolean') return typeof b === 'boolean' ? compareNSB(a, b) : -1;\n  if (typeof b === 'boolean') return typeof a === 'boolean' ? compareNSB(a, b) : 1;\n\n  // Dates\n  if (isDate(a)) return isDate(b) ? compareNSB(a.getTime(), b.getTime()) : -1;\n  if (isDate(b)) return isDate(a) ? compareNSB(a.getTime(), b.getTime()) : 1;\n\n  // Arrays (first element is most significant and so on)\n  if (Array.isArray(a)) return Array.isArray(b) ? compareArrays(a, b) : -1;\n  if (Array.isArray(b)) return Array.isArray(a) ? compareArrays(a, b) : 1;\n\n  // Objects\n  const aKeys = Object.keys(a).sort();\n  const bKeys = Object.keys(b).sort();\n  for (let i = 0; i < Math.min(aKeys.length, bKeys.length); i += 1) {\n    const comp = compareThings(a[aKeys[i]], b[bKeys[i]]);\n    if (comp !== 0) return comp;\n  }\n  return compareNSB(aKeys.length, bKeys.length);\n};\n\n// ==============================================================\n// Updating documents\n// ==============================================================\n\n/**\n * @callback modifierFunction\n * The signature of modifier functions is as follows\n * Their structure is always the same: recursively follow the dot notation while creating\n * the nested documents if needed, then apply the \"last step modifier\"\n * @param {Object} obj The model to modify\n * @param {String} field Can contain dots, in that case that means we will set a subfield recursively\n * @param {document} value\n */\n\n/**\n * Create the complete modifier function\n * @param {modifierFunction} lastStepModifierFunction a lastStepModifierFunction\n * @param {boolean} [unset = false] Bad looking specific fix, needs to be generalized modifiers that behave like $unset are implemented\n * @return {modifierFunction}\n * @private\n */\nconst createModifierFunction = (lastStepModifierFunction, unset = false) => {\n  const func = (obj, field, value) => {\n    const fieldParts = typeof field === 'string' ? field.split('.') : field;\n    if (fieldParts.length === 1) lastStepModifierFunction(obj, field, value);else {\n      if (obj[fieldParts[0]] === undefined) {\n        if (unset) return;\n        obj[fieldParts[0]] = {};\n      }\n      func(obj[fieldParts[0]], fieldParts.slice(1), value);\n    }\n  };\n  return func;\n};\nconst $addToSetPartial = (obj, field, value) => {\n  // Create the array if it doesn't exist\n  if (!Object.prototype.hasOwnProperty.call(obj, field)) {\n    obj[field] = [];\n  }\n  if (!Array.isArray(obj[field])) throw new Error('Can\\'t $addToSet an element on non-array values');\n  if (value !== null && typeof value === 'object' && value.$each) {\n    if (Object.keys(value).length > 1) throw new Error('Can\\'t use another field in conjunction with $each');\n    if (!Array.isArray(value.$each)) throw new Error('$each requires an array value');\n    value.$each.forEach(v => {\n      $addToSetPartial(obj, field, v);\n    });\n  } else {\n    let addToSet = true;\n    obj[field].forEach(v => {\n      if (compareThings(v, value) === 0) addToSet = false;\n    });\n    if (addToSet) obj[field].push(value);\n  }\n};\n\n/**\n * @enum {modifierFunction}\n */\nconst modifierFunctions = {\n  /**\n   * Set a field to a new value\n   */\n  $set: createModifierFunction((obj, field, value) => {\n    obj[field] = value;\n  }),\n  /**\n   * Unset a field\n   */\n  $unset: createModifierFunction((obj, field, value) => {\n    delete obj[field];\n  }, true),\n  /**\n   * Updates the value of the field, only if specified field is smaller than the current value of the field\n   */\n  $min: createModifierFunction((obj, field, value) => {\n    if (typeof obj[field] === 'undefined') obj[field] = value;else if (value < obj[field]) obj[field] = value;\n  }),\n  /**\n   * Updates the value of the field, only if specified field is greater than the current value of the field\n   */\n  $max: createModifierFunction((obj, field, value) => {\n    if (typeof obj[field] === 'undefined') obj[field] = value;else if (value > obj[field]) obj[field] = value;\n  }),\n  /**\n   * Increment a numeric field's value\n   */\n  $inc: createModifierFunction((obj, field, value) => {\n    if (typeof value !== 'number') throw new Error(`${value} must be a number`);\n    if (typeof obj[field] !== 'number') {\n      if (!Object.prototype.hasOwnProperty.call(obj, field)) obj[field] = value;else throw new Error('Don\\'t use the $inc modifier on non-number fields');\n    } else obj[field] += value;\n  }),\n  /**\n   * Removes all instances of a value from an existing array\n   */\n  $pull: createModifierFunction((obj, field, value) => {\n    if (!Array.isArray(obj[field])) throw new Error('Can\\'t $pull an element from non-array values');\n    const arr = obj[field];\n    for (let i = arr.length - 1; i >= 0; i -= 1) {\n      if (match(arr[i], value)) arr.splice(i, 1);\n    }\n  }),\n  /**\n   * Remove the first or last element of an array\n   */\n  $pop: createModifierFunction((obj, field, value) => {\n    if (!Array.isArray(obj[field])) throw new Error('Can\\'t $pop an element from non-array values');\n    if (typeof value !== 'number') throw new Error(`${value} isn't an integer, can't use it with $pop`);\n    if (value === 0) return;\n    if (value > 0) obj[field] = obj[field].slice(0, obj[field].length - 1);else obj[field] = obj[field].slice(1);\n  }),\n  /**\n   * Add an element to an array field only if it is not already in it\n   * No modification if the element is already in the array\n   * Note that it doesn't check whether the original array contains duplicates\n   */\n  $addToSet: createModifierFunction($addToSetPartial),\n  /**\n   * Push an element to the end of an array field\n   * Optional modifier $each instead of value to push several values\n   * Optional modifier $slice to slice the resulting array, see https://docs.mongodb.org/manual/reference/operator/update/slice/\n   * Difference with MongoDB: if $slice is specified and not $each, we act as if value is an empty array\n   */\n  $push: createModifierFunction((obj, field, value) => {\n    // Create the array if it doesn't exist\n    if (!Object.prototype.hasOwnProperty.call(obj, field)) obj[field] = [];\n    if (!Array.isArray(obj[field])) throw new Error('Can\\'t $push an element on non-array values');\n    if (value !== null && typeof value === 'object' && value.$slice && value.$each === undefined) value.$each = [];\n    if (value !== null && typeof value === 'object' && value.$each) {\n      if (Object.keys(value).length >= 3 || Object.keys(value).length === 2 && value.$slice === undefined) throw new Error('Can only use $slice in cunjunction with $each when $push to array');\n      if (!Array.isArray(value.$each)) throw new Error('$each requires an array value');\n      value.$each.forEach(v => {\n        obj[field].push(v);\n      });\n      if (value.$slice === undefined || typeof value.$slice !== 'number') return;\n      if (value.$slice === 0) obj[field] = [];else {\n        let start;\n        let end;\n        const n = obj[field].length;\n        if (value.$slice < 0) {\n          start = Math.max(0, n + value.$slice);\n          end = n;\n        } else if (value.$slice > 0) {\n          start = 0;\n          end = Math.min(n, value.$slice);\n        }\n        obj[field] = obj[field].slice(start, end);\n      }\n    } else {\n      obj[field].push(value);\n    }\n  })\n};\n\n/**\n * Modify a DB object according to an update query\n * @param {document} obj\n * @param {query} updateQuery\n * @return {document}\n * @alias module:model.modify\n */\nconst modify = (obj, updateQuery) => {\n  const keys = Object.keys(updateQuery);\n  const firstChars = keys.map(item => item[0]);\n  const dollarFirstChars = firstChars.filter(c => c === '$');\n  let newDoc;\n  let modifiers;\n  if (keys.indexOf('_id') !== -1 && updateQuery._id !== obj._id) throw new Error('You cannot change a document\\'s _id');\n  if (dollarFirstChars.length !== 0 && dollarFirstChars.length !== firstChars.length) throw new Error('You cannot mix modifiers and normal fields');\n  if (dollarFirstChars.length === 0) {\n    // Simply replace the object with the update query contents\n    newDoc = deepCopy(updateQuery);\n    newDoc._id = obj._id;\n  } else {\n    // Apply modifiers\n    modifiers = uniq(keys);\n    newDoc = deepCopy(obj);\n    modifiers.forEach(m => {\n      if (!modifierFunctions[m]) throw new Error(`Unknown modifier ${m}`);\n\n      // Can't rely on Object.keys throwing on non objects since ES6\n      // Not 100% satisfying as non objects can be interpreted as objects but no false negatives so we can live with it\n      if (typeof updateQuery[m] !== 'object') throw new Error(`Modifier ${m}'s argument must be an object`);\n      const keys = Object.keys(updateQuery[m]);\n      keys.forEach(k => {\n        modifierFunctions[m](newDoc, k, updateQuery[m][k]);\n      });\n    });\n  }\n\n  // Check result is valid and return it\n  checkObject(newDoc);\n  if (obj._id !== newDoc._id) throw new Error('You can\\'t change a document\\'s _id');\n  return newDoc;\n};\n\n// ==============================================================\n// Finding documents\n// ==============================================================\n\n/**\n * Get a value from object with dot notation\n * @param {object} obj\n * @param {string} field\n * @return {*}\n * @alias module:model.getDotValue\n */\nconst getDotValue = (obj, field) => {\n  const fieldParts = typeof field === 'string' ? field.split('.') : field;\n  if (!obj) return undefined; // field cannot be empty so that means we should return undefined so that nothing can match\n\n  if (fieldParts.length === 0) return obj;\n  if (fieldParts.length === 1) return obj[fieldParts[0]];\n  if (Array.isArray(obj[fieldParts[0]])) {\n    // If the next field is an integer, return only this item of the array\n    const i = parseInt(fieldParts[1], 10);\n    if (typeof i === 'number' && !isNaN(i)) return getDotValue(obj[fieldParts[0]][i], fieldParts.slice(2));\n\n    // Return the array of values\n    return obj[fieldParts[0]].map(el => getDotValue(el, fieldParts.slice(1)));\n  } else return getDotValue(obj[fieldParts[0]], fieldParts.slice(1));\n};\n\n/**\n * Get dot values for either a bunch of fields or just one.\n */\nconst getDotValues = (obj, fields) => {\n  if (!Array.isArray(fields)) throw new Error('fields must be an Array');\n  if (fields.length > 1) {\n    const key = {};\n    for (const field of fields) {\n      key[field] = getDotValue(obj, field);\n    }\n    return key;\n  } else return getDotValue(obj, fields[0]);\n};\n\n/**\n * Check whether 'things' are equal\n * Things are defined as any native types (string, number, boolean, null, date) and objects\n * In the case of object, we check deep equality\n * Returns true if they are, false otherwise\n * @param {*} a\n * @param {*} a\n * @return {boolean}\n * @alias module:model.areThingsEqual\n */\nconst areThingsEqual = (a, b) => {\n  // Strings, booleans, numbers, null\n  if (a === null || typeof a === 'string' || typeof a === 'boolean' || typeof a === 'number' || b === null || typeof b === 'string' || typeof b === 'boolean' || typeof b === 'number') return a === b;\n\n  // Dates\n  if (isDate(a) || isDate(b)) return isDate(a) && isDate(b) && a.getTime() === b.getTime();\n\n  // Arrays (no match since arrays are used as a $in)\n  // undefined (no match since they mean field doesn't exist and can't be serialized)\n  if (!(Array.isArray(a) && Array.isArray(b)) && (Array.isArray(a) || Array.isArray(b)) || a === undefined || b === undefined) return false;\n\n  // General objects (check for deep equality)\n  // a and b should be objects at this point\n  let aKeys;\n  let bKeys;\n  try {\n    aKeys = Object.keys(a);\n    bKeys = Object.keys(b);\n  } catch (e) {\n    return false;\n  }\n  if (aKeys.length !== bKeys.length) return false;\n  for (const el of aKeys) {\n    if (bKeys.indexOf(el) === -1) return false;\n    if (!areThingsEqual(a[el], b[el])) return false;\n  }\n  return true;\n};\n\n/**\n * Check that two values are comparable\n * @param {*} a\n * @param {*} a\n * @return {boolean}\n * @private\n */\nconst areComparable = (a, b) => {\n  if (typeof a !== 'string' && typeof a !== 'number' && !isDate(a) && typeof b !== 'string' && typeof b !== 'number' && !isDate(b)) return false;\n  if (typeof a !== typeof b) return false;\n  return true;\n};\n\n/**\n * @callback comparisonOperator\n * Arithmetic and comparison operators\n * @param {*} a Value in the object\n * @param {*} b Value in the query\n * @return {boolean}\n */\n\n/**\n * @enum {comparisonOperator}\n */\nconst comparisonFunctions = {\n  /** Lower than */\n  $lt: (a, b) => areComparable(a, b) && a < b,\n  /** Lower than or equals */\n  $lte: (a, b) => areComparable(a, b) && a <= b,\n  /** Greater than */\n  $gt: (a, b) => areComparable(a, b) && a > b,\n  /** Greater than or equals */\n  $gte: (a, b) => areComparable(a, b) && a >= b,\n  /** Does not equal */\n  $ne: (a, b) => a === undefined || !areThingsEqual(a, b),\n  /** Is in Array */\n  $in: (a, b) => {\n    if (!Array.isArray(b)) throw new Error('$in operator called with a non-array');\n    for (const el of b) {\n      if (areThingsEqual(a, el)) return true;\n    }\n    return false;\n  },\n  /** Is not in Array */\n  $nin: (a, b) => {\n    if (!Array.isArray(b)) throw new Error('$nin operator called with a non-array');\n    return !comparisonFunctions.$in(a, b);\n  },\n  /** Matches Regexp */\n  $regex: (a, b) => {\n    if (!isRegExp(b)) throw new Error('$regex operator called with non regular expression');\n    if (typeof a !== 'string') return false;else return b.test(a);\n  },\n  /** Returns true if field exists */\n  $exists: (a, b) => {\n    // This will be true for all values of stat except false, null, undefined and 0\n    // That's strange behaviour (we should only use true/false) but that's the way Mongo does it...\n    if (b || b === '') b = true;else b = false;\n    if (a === undefined) return !b;else return b;\n  },\n  /** Specific to Arrays, returns true if a length equals b */\n  $size: (a, b) => {\n    if (!Array.isArray(a)) return false;\n    if (b % 1 !== 0) throw new Error('$size operator called without an integer');\n    return a.length === b;\n  },\n  /** Specific to Arrays, returns true if some elements of a match the query b */\n  $elemMatch: (a, b) => {\n    if (!Array.isArray(a)) return false;\n    return a.some(el => match(el, b));\n  }\n};\nconst arrayComparisonFunctions = {\n  $size: true,\n  $elemMatch: true\n};\n\n/**\n * @enum\n */\nconst logicalOperators = {\n  /**\n   * Match any of the subqueries\n   * @param {document} obj\n   * @param {query[]} query\n   * @return {boolean}\n   */\n  $or: (obj, query) => {\n    if (!Array.isArray(query)) throw new Error('$or operator used without an array');\n    for (let i = 0; i < query.length; i += 1) {\n      if (match(obj, query[i])) return true;\n    }\n    return false;\n  },\n  /**\n   * Match all of the subqueries\n   * @param {document} obj\n   * @param {query[]} query\n   * @return {boolean}\n   */\n  $and: (obj, query) => {\n    if (!Array.isArray(query)) throw new Error('$and operator used without an array');\n    for (let i = 0; i < query.length; i += 1) {\n      if (!match(obj, query[i])) return false;\n    }\n    return true;\n  },\n  /**\n   * Inverted match of the query\n   * @param {document} obj\n   * @param {query} query\n   * @return {boolean}\n   */\n  $not: (obj, query) => !match(obj, query),\n  /**\n   * @callback whereCallback\n   * @param {document} obj\n   * @return {boolean}\n   */\n\n  /**\n   * Use a function to match\n   * @param {document} obj\n   * @param {whereCallback} fn\n   * @return {boolean}\n   */\n  $where: (obj, fn) => {\n    if (typeof fn !== 'function') throw new Error('$where operator used without a function');\n    const result = fn.call(obj);\n    if (typeof result !== 'boolean') throw new Error('$where function must return boolean');\n    return result;\n  }\n};\n\n/**\n * Tell if a given document matches a query\n * @param {document} obj Document to check\n * @param {query} query\n * @return {boolean}\n * @alias module:model.match\n */\nconst match = (obj, query) => {\n  // Primitive query against a primitive type\n  // This is a bit of a hack since we construct an object with an arbitrary key only to dereference it later\n  // But I don't have time for a cleaner implementation now\n  if (isPrimitiveType(obj) || isPrimitiveType(query)) return matchQueryPart({\n    needAKey: obj\n  }, 'needAKey', query);\n\n  // Normal query\n  for (const queryKey in query) {\n    if (Object.prototype.hasOwnProperty.call(query, queryKey)) {\n      const queryValue = query[queryKey];\n      if (queryKey[0] === '$') {\n        if (!logicalOperators[queryKey]) throw new Error(`Unknown logical operator ${queryKey}`);\n        if (!logicalOperators[queryKey](obj, queryValue)) return false;\n      } else if (!matchQueryPart(obj, queryKey, queryValue)) return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Match an object against a specific { key: value } part of a query\n * if the treatObjAsValue flag is set, don't try to match every part separately, but the array as a whole\n * @param {object} obj\n * @param {string} queryKey\n * @param {*} queryValue\n * @param {boolean} [treatObjAsValue=false]\n * @return {boolean}\n * @private\n */\nfunction matchQueryPart(obj, queryKey, queryValue, treatObjAsValue) {\n  const objValue = getDotValue(obj, queryKey);\n\n  // Check if the value is an array if we don't force a treatment as value\n  if (Array.isArray(objValue) && !treatObjAsValue) {\n    // If the queryValue is an array, try to perform an exact match\n    if (Array.isArray(queryValue)) return matchQueryPart(obj, queryKey, queryValue, true);\n\n    // Check if we are using an array-specific comparison function\n    if (queryValue !== null && typeof queryValue === 'object' && !isRegExp(queryValue)) {\n      for (const key in queryValue) {\n        if (Object.prototype.hasOwnProperty.call(queryValue, key) && arrayComparisonFunctions[key]) {\n          return matchQueryPart(obj, queryKey, queryValue, true);\n        }\n      }\n    }\n\n    // If not, treat it as an array of { obj, query } where there needs to be at least one match\n    for (const el of objValue) {\n      if (matchQueryPart({\n        k: el\n      }, 'k', queryValue)) return true; // k here could be any string\n    }\n    return false;\n  }\n\n  // queryValue is an actual object. Determine whether it contains comparison operators\n  // or only normal fields. Mixed objects are not allowed\n  if (queryValue !== null && typeof queryValue === 'object' && !isRegExp(queryValue) && !Array.isArray(queryValue)) {\n    const keys = Object.keys(queryValue);\n    const firstChars = keys.map(item => item[0]);\n    const dollarFirstChars = firstChars.filter(c => c === '$');\n    if (dollarFirstChars.length !== 0 && dollarFirstChars.length !== firstChars.length) throw new Error('You cannot mix operators and normal fields');\n\n    // queryValue is an object of this form: { $comparisonOperator1: value1, ... }\n    if (dollarFirstChars.length > 0) {\n      for (const key of keys) {\n        if (!comparisonFunctions[key]) throw new Error(`Unknown comparison function ${key}`);\n        if (!comparisonFunctions[key](objValue, queryValue[key])) return false;\n      }\n      return true;\n    }\n  }\n\n  // Using regular expressions with basic querying\n  if (isRegExp(queryValue)) return comparisonFunctions.$regex(objValue, queryValue);\n\n  // queryValue is either a native value or a normal object\n  // Basic matching is possible\n  return areThingsEqual(objValue, queryValue);\n}\n\n// Interface\nmodule.exports.serialize = serialize;\nmodule.exports.deserialize = deserialize;\nmodule.exports.deepCopy = deepCopy;\nmodule.exports.checkObject = checkObject;\nmodule.exports.isPrimitiveType = isPrimitiveType;\nmodule.exports.modify = modify;\nmodule.exports.getDotValue = getDotValue;\nmodule.exports.getDotValues = getDotValues;\nmodule.exports.match = match;\nmodule.exports.areThingsEqual = areThingsEqual;\nmodule.exports.compareThings = compareThings;","map":{"version":3,"names":["uniq","isDate","isRegExp","require","checkKey","k","v","toString","Error","indexOf","checkObject","obj","Array","isArray","forEach","o","Object","prototype","hasOwnProperty","call","serialize","JSON","stringify","undefined","getTime","$$date","deserialize","rawData","parse","Date","deepCopy","strictKeys","map","res","isPrimitiveType","compareNSB","a","b","compareArrays","minLength","Math","min","length","i","comp","compareThings","_compareStrings","compareStrings","aKeys","keys","sort","bKeys","createModifierFunction","lastStepModifierFunction","unset","func","field","value","fieldParts","split","slice","$addToSetPartial","$each","addToSet","push","modifierFunctions","$set","$unset","$min","$max","$inc","$pull","arr","match","splice","$pop","$addToSet","$push","$slice","start","end","n","max","modify","updateQuery","firstChars","item","dollarFirstChars","filter","c","newDoc","modifiers","_id","m","getDotValue","parseInt","isNaN","el","getDotValues","fields","key","areThingsEqual","e","areComparable","comparisonFunctions","$lt","$lte","$gt","$gte","$ne","$in","$nin","$regex","test","$exists","$size","$elemMatch","some","arrayComparisonFunctions","logicalOperators","$or","query","$and","$not","$where","fn","result","matchQueryPart","needAKey","queryKey","queryValue","treatObjAsValue","objValue","module","exports"],"sources":["C:/Users/benit/Music/arbisout/node_modules/@seald-io/nedb/lib/model.js"],"sourcesContent":["/**\n * Handle models (i.e. docs)\n * Serialization/deserialization\n * Copying\n * Querying, update\n * @module model\n * @private\n */\nconst { uniq, isDate, isRegExp } = require('./utils.js')\n\n/**\n * Check a key, throw an error if the key is non valid\n * @param {string} k key\n * @param {document} v value, needed to treat the Date edge case\n * Non-treatable edge cases here: if part of the object if of the form { $$date: number } or { $$deleted: true }\n * Its serialized-then-deserialized version it will transformed into a Date object\n * But you really need to want it to trigger such behaviour, even when warned not to use '$' at the beginning of the field names...\n * @private\n */\nconst checkKey = (k, v) => {\n  if (typeof k === 'number') k = k.toString()\n\n  if (\n    k[0] === '$' &&\n    !(k === '$$date' && typeof v === 'number') &&\n    !(k === '$$deleted' && v === true) &&\n    !(k === '$$indexCreated') &&\n    !(k === '$$indexRemoved')\n  ) throw new Error('Field names cannot begin with the $ character')\n\n  if (k.indexOf('.') !== -1) throw new Error('Field names cannot contain a .')\n}\n\n/**\n * Check a DB object and throw an error if it's not valid\n * Works by applying the above checkKey function to all fields recursively\n * @param {document|document[]} obj\n * @alias module:model.checkObject\n */\nconst checkObject = obj => {\n  if (Array.isArray(obj)) {\n    obj.forEach(o => {\n      checkObject(o)\n    })\n  }\n\n  if (typeof obj === 'object' && obj !== null) {\n    for (const k in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, k)) {\n        checkKey(k, obj[k])\n        checkObject(obj[k])\n      }\n    }\n  }\n}\n\n/**\n * Serialize an object to be persisted to a one-line string\n * For serialization/deserialization, we use the native JSON parser and not eval or Function\n * That gives us less freedom but data entered in the database may come from users\n * so eval and the like are not safe\n * Accepted primitive types: Number, String, Boolean, Date, null\n * Accepted secondary types: Objects, Arrays\n * @param {document} obj\n * @return {string}\n * @alias module:model.serialize\n */\nconst serialize = obj => {\n  return JSON.stringify(obj, function (k, v) {\n    checkKey(k, v)\n\n    if (v === undefined) return undefined\n    if (v === null) return null\n\n    // Hackish way of checking if object is Date (this way it works between execution contexts in node-webkit).\n    // We can't use value directly because for dates it is already string in this function (date.toJSON was already called), so we use this\n    if (typeof this[k].getTime === 'function') return { $$date: this[k].getTime() }\n\n    return v\n  })\n}\n\n/**\n * From a one-line representation of an object generate by the serialize function\n * Return the object itself\n * @param {string} rawData\n * @return {document}\n * @alias module:model.deserialize\n */\nconst deserialize = rawData => JSON.parse(rawData, function (k, v) {\n  if (k === '$$date') return new Date(v)\n  if (\n    typeof v === 'string' ||\n    typeof v === 'number' ||\n    typeof v === 'boolean' ||\n    v === null\n  ) return v\n  if (v && v.$$date) return v.$$date\n\n  return v\n})\n\n/**\n * Deep copy a DB object\n * The optional strictKeys flag (defaulting to false) indicates whether to copy everything or only fields\n * where the keys are valid, i.e. don't begin with $ and don't contain a .\n * @param {?document} obj\n * @param {boolean} [strictKeys=false]\n * @return {?document}\n * @alias module:modelel:(.*)\n */\nfunction deepCopy (obj, strictKeys) {\n  if (\n    typeof obj === 'boolean' ||\n    typeof obj === 'number' ||\n    typeof obj === 'string' ||\n    obj === null ||\n    (isDate(obj))\n  ) return obj\n\n  if (Array.isArray(obj)) return obj.map(o => deepCopy(o, strictKeys))\n\n  if (typeof obj === 'object') {\n    const res = {}\n    for (const k in obj) {\n      if (\n        Object.prototype.hasOwnProperty.call(obj, k) &&\n        (!strictKeys || (k[0] !== '$' && k.indexOf('.') === -1))\n      ) {\n        res[k] = deepCopy(obj[k], strictKeys)\n      }\n    }\n    return res\n  }\n\n  return undefined // For now everything else is undefined. We should probably throw an error instead\n}\n\n/**\n * Tells if an object is a primitive type or a \"real\" object\n * Arrays are considered primitive\n * @param {*} obj\n * @return {boolean}\n * @alias module:modelel:(.*)\n */\nconst isPrimitiveType = obj => (\n  typeof obj === 'boolean' ||\n  typeof obj === 'number' ||\n  typeof obj === 'string' ||\n  obj === null ||\n  isDate(obj) ||\n  Array.isArray(obj)\n)\n\n/**\n * Utility functions for comparing things\n * Assumes type checking was already done (a and b already have the same type)\n * compareNSB works for numbers, strings and booleans\n * @param {number|string|boolean} a\n * @param {number|string|boolean} b\n * @return {number} 0 if a == b, 1 i a > b, -1 if a < b\n * @private\n */\nconst compareNSB = (a, b) => {\n  if (a < b) return -1\n  if (a > b) return 1\n  return 0\n}\n\n/**\n * Utility function for comparing array\n * Assumes type checking was already done (a and b already have the same type)\n * compareNSB works for numbers, strings and booleans\n * @param {Array} a\n * @param {Array} b\n * @return {number} 0 if arrays have the same length and all elements equal one another. Else either 1 or -1.\n * @private\n */\nconst compareArrays = (a, b) => {\n  const minLength = Math.min(a.length, b.length)\n  for (let i = 0; i < minLength; i += 1) {\n    const comp = compareThings(a[i], b[i])\n\n    if (comp !== 0) return comp\n  }\n\n  // Common section was identical, longest one wins\n  return compareNSB(a.length, b.length)\n}\n\n/**\n * Compare { things U undefined }\n * Things are defined as any native types (string, number, boolean, null, date) and objects\n * We need to compare with undefined as it will be used in indexes\n * In the case of objects and arrays, we deep-compare\n * If two objects dont have the same type, the (arbitrary) type hierarchy is: undefined, null, number, strings, boolean, dates, arrays, objects\n * Return -1 if a < b, 1 if a > b and 0 if a = b (note that equality here is NOT the same as defined in areThingsEqual!)\n * @param {*} a\n * @param {*} b\n * @param {compareStrings} [_compareStrings] String comparing function, returning -1, 0 or 1, overriding default string comparison (useful for languages with accented letters)\n * @return {number}\n * @alias module:model.compareThings\n */\nconst compareThings = (a, b, _compareStrings) => {\n  const compareStrings = _compareStrings || compareNSB\n\n  // undefined\n  if (a === undefined) return b === undefined ? 0 : -1\n  if (b === undefined) return 1 // no need to test if a === undefined\n\n  // null\n  if (a === null) return b === null ? 0 : -1\n  if (b === null) return 1 // no need to test if a === null\n\n  // Numbers\n  if (typeof a === 'number') return typeof b === 'number' ? compareNSB(a, b) : -1\n  if (typeof b === 'number') return typeof a === 'number' ? compareNSB(a, b) : 1\n\n  // Strings\n  if (typeof a === 'string') return typeof b === 'string' ? compareStrings(a, b) : -1\n  if (typeof b === 'string') return typeof a === 'string' ? compareStrings(a, b) : 1\n\n  // Booleans\n  if (typeof a === 'boolean') return typeof b === 'boolean' ? compareNSB(a, b) : -1\n  if (typeof b === 'boolean') return typeof a === 'boolean' ? compareNSB(a, b) : 1\n\n  // Dates\n  if (isDate(a)) return isDate(b) ? compareNSB(a.getTime(), b.getTime()) : -1\n  if (isDate(b)) return isDate(a) ? compareNSB(a.getTime(), b.getTime()) : 1\n\n  // Arrays (first element is most significant and so on)\n  if (Array.isArray(a)) return Array.isArray(b) ? compareArrays(a, b) : -1\n  if (Array.isArray(b)) return Array.isArray(a) ? compareArrays(a, b) : 1\n\n  // Objects\n  const aKeys = Object.keys(a).sort()\n  const bKeys = Object.keys(b).sort()\n\n  for (let i = 0; i < Math.min(aKeys.length, bKeys.length); i += 1) {\n    const comp = compareThings(a[aKeys[i]], b[bKeys[i]])\n\n    if (comp !== 0) return comp\n  }\n\n  return compareNSB(aKeys.length, bKeys.length)\n}\n\n// ==============================================================\n// Updating documents\n// ==============================================================\n\n/**\n * @callback modifierFunction\n * The signature of modifier functions is as follows\n * Their structure is always the same: recursively follow the dot notation while creating\n * the nested documents if needed, then apply the \"last step modifier\"\n * @param {Object} obj The model to modify\n * @param {String} field Can contain dots, in that case that means we will set a subfield recursively\n * @param {document} value\n */\n\n/**\n * Create the complete modifier function\n * @param {modifierFunction} lastStepModifierFunction a lastStepModifierFunction\n * @param {boolean} [unset = false] Bad looking specific fix, needs to be generalized modifiers that behave like $unset are implemented\n * @return {modifierFunction}\n * @private\n */\nconst createModifierFunction = (lastStepModifierFunction, unset = false) => {\n  const func = (obj, field, value) => {\n    const fieldParts = typeof field === 'string' ? field.split('.') : field\n\n    if (fieldParts.length === 1) lastStepModifierFunction(obj, field, value)\n    else {\n      if (obj[fieldParts[0]] === undefined) {\n        if (unset) return\n        obj[fieldParts[0]] = {}\n      }\n      func(obj[fieldParts[0]], fieldParts.slice(1), value)\n    }\n  }\n  return func\n}\n\nconst $addToSetPartial = (obj, field, value) => {\n  // Create the array if it doesn't exist\n  if (!Object.prototype.hasOwnProperty.call(obj, field)) { obj[field] = [] }\n\n  if (!Array.isArray(obj[field])) throw new Error('Can\\'t $addToSet an element on non-array values')\n\n  if (value !== null && typeof value === 'object' && value.$each) {\n    if (Object.keys(value).length > 1) throw new Error('Can\\'t use another field in conjunction with $each')\n    if (!Array.isArray(value.$each)) throw new Error('$each requires an array value')\n\n    value.$each.forEach(v => {\n      $addToSetPartial(obj, field, v)\n    })\n  } else {\n    let addToSet = true\n    obj[field].forEach(v => {\n      if (compareThings(v, value) === 0) addToSet = false\n    })\n    if (addToSet) obj[field].push(value)\n  }\n}\n\n/**\n * @enum {modifierFunction}\n */\nconst modifierFunctions = {\n  /**\n   * Set a field to a new value\n   */\n  $set: createModifierFunction((obj, field, value) => {\n    obj[field] = value\n  }),\n  /**\n   * Unset a field\n   */\n  $unset: createModifierFunction((obj, field, value) => {\n    delete obj[field]\n  }, true),\n  /**\n   * Updates the value of the field, only if specified field is smaller than the current value of the field\n   */\n  $min: createModifierFunction((obj, field, value) => {\n    if (typeof obj[field] === 'undefined') obj[field] = value\n    else if (value < obj[field]) obj[field] = value\n  }),\n  /**\n   * Updates the value of the field, only if specified field is greater than the current value of the field\n   */\n  $max: createModifierFunction((obj, field, value) => {\n    if (typeof obj[field] === 'undefined') obj[field] = value\n    else if (value > obj[field]) obj[field] = value\n  }),\n  /**\n   * Increment a numeric field's value\n   */\n  $inc: createModifierFunction((obj, field, value) => {\n    if (typeof value !== 'number') throw new Error(`${value} must be a number`)\n\n    if (typeof obj[field] !== 'number') {\n      if (!Object.prototype.hasOwnProperty.call(obj, field)) obj[field] = value\n      else throw new Error('Don\\'t use the $inc modifier on non-number fields')\n    } else obj[field] += value\n  }),\n  /**\n   * Removes all instances of a value from an existing array\n   */\n  $pull: createModifierFunction((obj, field, value) => {\n    if (!Array.isArray(obj[field])) throw new Error('Can\\'t $pull an element from non-array values')\n\n    const arr = obj[field]\n    for (let i = arr.length - 1; i >= 0; i -= 1) {\n      if (match(arr[i], value)) arr.splice(i, 1)\n    }\n  }),\n  /**\n   * Remove the first or last element of an array\n   */\n  $pop: createModifierFunction((obj, field, value) => {\n    if (!Array.isArray(obj[field])) throw new Error('Can\\'t $pop an element from non-array values')\n    if (typeof value !== 'number') throw new Error(`${value} isn't an integer, can't use it with $pop`)\n    if (value === 0) return\n\n    if (value > 0) obj[field] = obj[field].slice(0, obj[field].length - 1)\n    else obj[field] = obj[field].slice(1)\n  }),\n  /**\n   * Add an element to an array field only if it is not already in it\n   * No modification if the element is already in the array\n   * Note that it doesn't check whether the original array contains duplicates\n   */\n  $addToSet: createModifierFunction($addToSetPartial),\n  /**\n   * Push an element to the end of an array field\n   * Optional modifier $each instead of value to push several values\n   * Optional modifier $slice to slice the resulting array, see https://docs.mongodb.org/manual/reference/operator/update/slice/\n   * Difference with MongoDB: if $slice is specified and not $each, we act as if value is an empty array\n   */\n  $push: createModifierFunction((obj, field, value) => {\n    // Create the array if it doesn't exist\n    if (!Object.prototype.hasOwnProperty.call(obj, field)) obj[field] = []\n\n    if (!Array.isArray(obj[field])) throw new Error('Can\\'t $push an element on non-array values')\n\n    if (\n      value !== null &&\n      typeof value === 'object' &&\n      value.$slice &&\n      value.$each === undefined\n    ) value.$each = []\n\n    if (value !== null && typeof value === 'object' && value.$each) {\n      if (\n        Object.keys(value).length >= 3 ||\n        (Object.keys(value).length === 2 && value.$slice === undefined)\n      ) throw new Error('Can only use $slice in cunjunction with $each when $push to array')\n      if (!Array.isArray(value.$each)) throw new Error('$each requires an array value')\n\n      value.$each.forEach(v => {\n        obj[field].push(v)\n      })\n\n      if (value.$slice === undefined || typeof value.$slice !== 'number') return\n\n      if (value.$slice === 0) obj[field] = []\n      else {\n        let start\n        let end\n        const n = obj[field].length\n        if (value.$slice < 0) {\n          start = Math.max(0, n + value.$slice)\n          end = n\n        } else if (value.$slice > 0) {\n          start = 0\n          end = Math.min(n, value.$slice)\n        }\n        obj[field] = obj[field].slice(start, end)\n      }\n    } else {\n      obj[field].push(value)\n    }\n  })\n\n}\n\n/**\n * Modify a DB object according to an update query\n * @param {document} obj\n * @param {query} updateQuery\n * @return {document}\n * @alias module:model.modify\n */\nconst modify = (obj, updateQuery) => {\n  const keys = Object.keys(updateQuery)\n  const firstChars = keys.map(item => item[0])\n  const dollarFirstChars = firstChars.filter(c => c === '$')\n  let newDoc\n  let modifiers\n\n  if (keys.indexOf('_id') !== -1 && updateQuery._id !== obj._id) throw new Error('You cannot change a document\\'s _id')\n\n  if (dollarFirstChars.length !== 0 && dollarFirstChars.length !== firstChars.length) throw new Error('You cannot mix modifiers and normal fields')\n\n  if (dollarFirstChars.length === 0) {\n    // Simply replace the object with the update query contents\n    newDoc = deepCopy(updateQuery)\n    newDoc._id = obj._id\n  } else {\n    // Apply modifiers\n    modifiers = uniq(keys)\n    newDoc = deepCopy(obj)\n    modifiers.forEach(m => {\n      if (!modifierFunctions[m]) throw new Error(`Unknown modifier ${m}`)\n\n      // Can't rely on Object.keys throwing on non objects since ES6\n      // Not 100% satisfying as non objects can be interpreted as objects but no false negatives so we can live with it\n      if (typeof updateQuery[m] !== 'object') throw new Error(`Modifier ${m}'s argument must be an object`)\n\n      const keys = Object.keys(updateQuery[m])\n      keys.forEach(k => {\n        modifierFunctions[m](newDoc, k, updateQuery[m][k])\n      })\n    })\n  }\n\n  // Check result is valid and return it\n  checkObject(newDoc)\n\n  if (obj._id !== newDoc._id) throw new Error('You can\\'t change a document\\'s _id')\n  return newDoc\n}\n\n// ==============================================================\n// Finding documents\n// ==============================================================\n\n/**\n * Get a value from object with dot notation\n * @param {object} obj\n * @param {string} field\n * @return {*}\n * @alias module:model.getDotValue\n */\nconst getDotValue = (obj, field) => {\n  const fieldParts = typeof field === 'string' ? field.split('.') : field\n\n  if (!obj) return undefined // field cannot be empty so that means we should return undefined so that nothing can match\n\n  if (fieldParts.length === 0) return obj\n\n  if (fieldParts.length === 1) return obj[fieldParts[0]]\n\n  if (Array.isArray(obj[fieldParts[0]])) {\n    // If the next field is an integer, return only this item of the array\n    const i = parseInt(fieldParts[1], 10)\n    if (typeof i === 'number' && !isNaN(i)) return getDotValue(obj[fieldParts[0]][i], fieldParts.slice(2))\n\n    // Return the array of values\n    return obj[fieldParts[0]].map(el => getDotValue(el, fieldParts.slice(1)))\n  } else return getDotValue(obj[fieldParts[0]], fieldParts.slice(1))\n}\n\n/**\n * Get dot values for either a bunch of fields or just one.\n */\nconst getDotValues = (obj, fields) => {\n  if (!Array.isArray(fields)) throw new Error('fields must be an Array')\n  if (fields.length > 1) {\n    const key = {}\n    for (const field of fields) {\n      key[field] = getDotValue(obj, field)\n    }\n    return key\n  } else return getDotValue(obj, fields[0])\n}\n\n/**\n * Check whether 'things' are equal\n * Things are defined as any native types (string, number, boolean, null, date) and objects\n * In the case of object, we check deep equality\n * Returns true if they are, false otherwise\n * @param {*} a\n * @param {*} a\n * @return {boolean}\n * @alias module:model.areThingsEqual\n */\nconst areThingsEqual = (a, b) => {\n  // Strings, booleans, numbers, null\n  if (\n    a === null ||\n    typeof a === 'string' ||\n    typeof a === 'boolean' ||\n    typeof a === 'number' ||\n    b === null ||\n    typeof b === 'string' ||\n    typeof b === 'boolean' ||\n    typeof b === 'number'\n  ) return a === b\n\n  // Dates\n  if (isDate(a) || isDate(b)) return isDate(a) && isDate(b) && a.getTime() === b.getTime()\n\n  // Arrays (no match since arrays are used as a $in)\n  // undefined (no match since they mean field doesn't exist and can't be serialized)\n  if (\n    (!(Array.isArray(a) && Array.isArray(b)) && (Array.isArray(a) || Array.isArray(b))) ||\n    a === undefined || b === undefined\n  ) return false\n\n  // General objects (check for deep equality)\n  // a and b should be objects at this point\n  let aKeys\n  let bKeys\n  try {\n    aKeys = Object.keys(a)\n    bKeys = Object.keys(b)\n  } catch (e) {\n    return false\n  }\n\n  if (aKeys.length !== bKeys.length) return false\n  for (const el of aKeys) {\n    if (bKeys.indexOf(el) === -1) return false\n    if (!areThingsEqual(a[el], b[el])) return false\n  }\n  return true\n}\n\n/**\n * Check that two values are comparable\n * @param {*} a\n * @param {*} a\n * @return {boolean}\n * @private\n */\nconst areComparable = (a, b) => {\n  if (\n    typeof a !== 'string' &&\n    typeof a !== 'number' &&\n    !isDate(a) &&\n    typeof b !== 'string' &&\n    typeof b !== 'number' &&\n    !isDate(b)\n  ) return false\n\n  if (typeof a !== typeof b) return false\n\n  return true\n}\n\n/**\n * @callback comparisonOperator\n * Arithmetic and comparison operators\n * @param {*} a Value in the object\n * @param {*} b Value in the query\n * @return {boolean}\n */\n\n/**\n * @enum {comparisonOperator}\n */\nconst comparisonFunctions = {\n  /** Lower than */\n  $lt: (a, b) => areComparable(a, b) && a < b,\n  /** Lower than or equals */\n  $lte: (a, b) => areComparable(a, b) && a <= b,\n  /** Greater than */\n  $gt: (a, b) => areComparable(a, b) && a > b,\n  /** Greater than or equals */\n  $gte: (a, b) => areComparable(a, b) && a >= b,\n  /** Does not equal */\n  $ne: (a, b) => a === undefined || !areThingsEqual(a, b),\n  /** Is in Array */\n  $in: (a, b) => {\n    if (!Array.isArray(b)) throw new Error('$in operator called with a non-array')\n\n    for (const el of b) {\n      if (areThingsEqual(a, el)) return true\n    }\n\n    return false\n  },\n  /** Is not in Array */\n  $nin: (a, b) => {\n    if (!Array.isArray(b)) throw new Error('$nin operator called with a non-array')\n\n    return !comparisonFunctions.$in(a, b)\n  },\n  /** Matches Regexp */\n  $regex: (a, b) => {\n    if (!isRegExp(b)) throw new Error('$regex operator called with non regular expression')\n\n    if (typeof a !== 'string') return false\n    else return b.test(a)\n  },\n  /** Returns true if field exists */\n  $exists: (a, b) => {\n    // This will be true for all values of stat except false, null, undefined and 0\n    // That's strange behaviour (we should only use true/false) but that's the way Mongo does it...\n    if (b || b === '') b = true\n    else b = false\n\n    if (a === undefined) return !b\n    else return b\n  },\n  /** Specific to Arrays, returns true if a length equals b */\n  $size: (a, b) => {\n    if (!Array.isArray(a)) return false\n    if (b % 1 !== 0) throw new Error('$size operator called without an integer')\n\n    return a.length === b\n  },\n  /** Specific to Arrays, returns true if some elements of a match the query b */\n  $elemMatch: (a, b) => {\n    if (!Array.isArray(a)) return false\n    return a.some(el => match(el, b))\n  }\n}\n\nconst arrayComparisonFunctions = { $size: true, $elemMatch: true }\n\n/**\n * @enum\n */\nconst logicalOperators = {\n  /**\n   * Match any of the subqueries\n   * @param {document} obj\n   * @param {query[]} query\n   * @return {boolean}\n   */\n  $or: (obj, query) => {\n    if (!Array.isArray(query)) throw new Error('$or operator used without an array')\n\n    for (let i = 0; i < query.length; i += 1) {\n      if (match(obj, query[i])) return true\n    }\n\n    return false\n  },\n  /**\n   * Match all of the subqueries\n   * @param {document} obj\n   * @param {query[]} query\n   * @return {boolean}\n   */\n  $and: (obj, query) => {\n    if (!Array.isArray(query)) throw new Error('$and operator used without an array')\n\n    for (let i = 0; i < query.length; i += 1) {\n      if (!match(obj, query[i])) return false\n    }\n\n    return true\n  },\n  /**\n   * Inverted match of the query\n   * @param {document} obj\n   * @param {query} query\n   * @return {boolean}\n   */\n  $not: (obj, query) => !match(obj, query),\n\n  /**\n   * @callback whereCallback\n   * @param {document} obj\n   * @return {boolean}\n   */\n\n  /**\n   * Use a function to match\n   * @param {document} obj\n   * @param {whereCallback} fn\n   * @return {boolean}\n   */\n  $where: (obj, fn) => {\n    if (typeof fn !== 'function') throw new Error('$where operator used without a function')\n\n    const result = fn.call(obj)\n    if (typeof result !== 'boolean') throw new Error('$where function must return boolean')\n\n    return result\n  }\n}\n\n/**\n * Tell if a given document matches a query\n * @param {document} obj Document to check\n * @param {query} query\n * @return {boolean}\n * @alias module:model.match\n */\nconst match = (obj, query) => {\n  // Primitive query against a primitive type\n  // This is a bit of a hack since we construct an object with an arbitrary key only to dereference it later\n  // But I don't have time for a cleaner implementation now\n  if (isPrimitiveType(obj) || isPrimitiveType(query)) return matchQueryPart({ needAKey: obj }, 'needAKey', query)\n\n  // Normal query\n  for (const queryKey in query) {\n    if (Object.prototype.hasOwnProperty.call(query, queryKey)) {\n      const queryValue = query[queryKey]\n      if (queryKey[0] === '$') {\n        if (!logicalOperators[queryKey]) throw new Error(`Unknown logical operator ${queryKey}`)\n        if (!logicalOperators[queryKey](obj, queryValue)) return false\n      } else if (!matchQueryPart(obj, queryKey, queryValue)) return false\n    }\n  }\n\n  return true\n}\n\n/**\n * Match an object against a specific { key: value } part of a query\n * if the treatObjAsValue flag is set, don't try to match every part separately, but the array as a whole\n * @param {object} obj\n * @param {string} queryKey\n * @param {*} queryValue\n * @param {boolean} [treatObjAsValue=false]\n * @return {boolean}\n * @private\n */\nfunction matchQueryPart (obj, queryKey, queryValue, treatObjAsValue) {\n  const objValue = getDotValue(obj, queryKey)\n\n  // Check if the value is an array if we don't force a treatment as value\n  if (Array.isArray(objValue) && !treatObjAsValue) {\n    // If the queryValue is an array, try to perform an exact match\n    if (Array.isArray(queryValue)) return matchQueryPart(obj, queryKey, queryValue, true)\n\n    // Check if we are using an array-specific comparison function\n    if (queryValue !== null && typeof queryValue === 'object' && !isRegExp(queryValue)) {\n      for (const key in queryValue) {\n        if (Object.prototype.hasOwnProperty.call(queryValue, key) && arrayComparisonFunctions[key]) { return matchQueryPart(obj, queryKey, queryValue, true) }\n      }\n    }\n\n    // If not, treat it as an array of { obj, query } where there needs to be at least one match\n    for (const el of objValue) {\n      if (matchQueryPart({ k: el }, 'k', queryValue)) return true // k here could be any string\n    }\n    return false\n  }\n\n  // queryValue is an actual object. Determine whether it contains comparison operators\n  // or only normal fields. Mixed objects are not allowed\n  if (queryValue !== null && typeof queryValue === 'object' && !isRegExp(queryValue) && !Array.isArray(queryValue)) {\n    const keys = Object.keys(queryValue)\n    const firstChars = keys.map(item => item[0])\n    const dollarFirstChars = firstChars.filter(c => c === '$')\n\n    if (dollarFirstChars.length !== 0 && dollarFirstChars.length !== firstChars.length) throw new Error('You cannot mix operators and normal fields')\n\n    // queryValue is an object of this form: { $comparisonOperator1: value1, ... }\n    if (dollarFirstChars.length > 0) {\n      for (const key of keys) {\n        if (!comparisonFunctions[key]) throw new Error(`Unknown comparison function ${key}`)\n\n        if (!comparisonFunctions[key](objValue, queryValue[key])) return false\n      }\n      return true\n    }\n  }\n\n  // Using regular expressions with basic querying\n  if (isRegExp(queryValue)) return comparisonFunctions.$regex(objValue, queryValue)\n\n  // queryValue is either a native value or a normal object\n  // Basic matching is possible\n  return areThingsEqual(objValue, queryValue)\n}\n\n// Interface\nmodule.exports.serialize = serialize\nmodule.exports.deserialize = deserialize\nmodule.exports.deepCopy = deepCopy\nmodule.exports.checkObject = checkObject\nmodule.exports.isPrimitiveType = isPrimitiveType\nmodule.exports.modify = modify\nmodule.exports.getDotValue = getDotValue\nmodule.exports.getDotValues = getDotValues\nmodule.exports.match = match\nmodule.exports.areThingsEqual = areThingsEqual\nmodule.exports.compareThings = compareThings\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}