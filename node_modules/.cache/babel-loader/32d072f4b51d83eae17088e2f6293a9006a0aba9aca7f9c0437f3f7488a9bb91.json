{"ast":null,"code":"const {\n  EventEmitter\n} = require('events');\nconst {\n  callbackify,\n  deprecate\n} = require('util');\nconst Cursor = require('./cursor.js');\nconst customUtils = require('./customUtils.js');\nconst Executor = require('./executor.js');\nconst Index = require('./indexes.js');\nconst model = require('./model.js');\nconst Persistence = require('./persistence.js');\nconst {\n  isDate,\n  pick,\n  filterIndexNames\n} = require('./utils.js');\n\n/**\n * Callback with no parameter\n * @callback NoParamCallback\n * @param {?Error} err\n */\n\n/**\n * String comparison function.\n * ```\n *   if (a < b) return -1\n *   if (a > b) return 1\n *   return 0\n * ```\n * @callback compareStrings\n * @param {string} a\n * @param {string} b\n * @return {number}\n */\n\n/**\n * Callback that returns an Array of documents.\n * @callback MultipleDocumentsCallback\n * @param {?Error} err\n * @param {?document[]} docs\n */\n\n/**\n * Callback that returns a single document.\n * @callback SingleDocumentCallback\n * @param {?Error} err\n * @param {?document} docs\n */\n\n/**\n * Generic async function.\n * @callback AsyncFunction\n * @param {...*} args\n * @return {Promise<*>}\n */\n\n/**\n * Callback with generic parameters.\n * @callback GenericCallback\n * @param {?Error} err\n * @param {...*} args\n */\n\n/**\n * Compaction event. Happens when the Datastore's Persistence has been compacted.\n * It happens when calling {@link Datastore#compactDatafileAsync}, which is called periodically if you have called\n * {@link Datastore#setAutocompactionInterval}.\n *\n * @event Datastore#event:\"compaction.done\"\n * @type {undefined}\n */\n\n/**\n * Generic document in NeDB.\n * It consists of an Object with anything you want inside.\n * @typedef document\n * @property {?string} [_id] Internal `_id` of the document, which can be `null` or undefined at some points (when not\n * inserted yet for example).\n * @type {object}\n */\n\n/**\n * Nedb query.\n *\n * Each key of a query references a field name, which can use the dot-notation to reference subfields inside nested\n * documents, arrays, arrays of subdocuments and to match a specific element of an array.\n *\n * Each value of a query can be one of the following:\n * - `string`: matches all documents which have this string as value for the referenced field name\n * - `number`: matches all documents which have this number as value for the referenced field name\n * - `Regexp`: matches all documents which have a value that matches the given `Regexp` for the referenced field name\n * - `object`: matches all documents which have this object as deep-value for the referenced field name\n * - Comparison operators: the syntax is `{ field: { $op: value } }` where `$op` is any comparison operator:\n *   - `$lt`, `$lte`: less than, less than or equal\n *   - `$gt`, `$gte`: greater than, greater than or equal\n *   - `$in`: member of. `value` must be an array of values\n *   - `$ne`, `$nin`: not equal, not a member of\n *   - `$exists`: checks whether the document posses the property `field`. `value` should be true or false\n *   - `$regex`: checks whether a string is matched by the regular expression. Contrary to MongoDB, the use of\n *   `$options` with `$regex` is not supported, because it doesn't give you more power than regex flags. Basic\n *   queries are more readable so only use the `$regex` operator when you need to use another operator with it\n *   - `$size`: if the referenced filed is an Array, matches on the size of the array\n *   - `$elemMatch`: matches if at least one array element matches the sub-query entirely\n * - Logical operators: You can combine queries using logical operators:\n *   - For `$or` and `$and`, the syntax is `{ $op: [query1, query2, ...] }`.\n *   - For `$not`, the syntax is `{ $not: query }`\n *   - For `$where`, the syntax is:\n *   ```\n *   { $where: function () {\n *     // object is 'this'\n *     // return a boolean\n *   } }\n *   ```\n * @typedef query\n * @type {Object.<string, *>}\n */\n\n/**\n * Nedb projection.\n *\n * You can give `find` and `findOne` an optional second argument, `projections`.\n * The syntax is the same as MongoDB: `{ a: 1, b: 1 }` to return only the `a`\n * and `b` fields, `{ a: 0, b: 0 }` to omit these two fields. You cannot use both\n * modes at the time, except for `_id` which is by default always returned and\n * which you can choose to omit. You can project on nested documents.\n *\n * To reference subfields, you can use the dot-notation.\n *\n * @typedef projection\n * @type {Object.<string, 0|1>}\n */\n\n/**\n * The `beforeDeserialization` and `afterSerialization` callbacks are hooks which are executed respectively before\n * parsing each document and after stringifying them. They can be used for example to encrypt the Datastore.\n * The `beforeDeserialization` should revert what `afterSerialization` has done.\n * @callback serializationHook\n * @param {string} x\n * @return {string|Promise<string>}\n */\n\n/**\n * @external EventEmitter\n * @see http://nodejs.org/api/events.html\n */\n\n/**\n * @class\n * @classdesc The `Datastore` class is the main class of NeDB.\n * @extends external:EventEmitter\n * @emits Datastore#event:\"compaction.done\"\n * @typicalname NeDB\n */\nclass Datastore extends EventEmitter {\n  /**\n   * Create a new collection, either persistent or in-memory.\n   *\n   * If you use a persistent datastore without the `autoload` option, you need to call {@link Datastore#loadDatabase} or\n   * {@link Datastore#loadDatabaseAsync} manually. This function fetches the data from datafile and prepares the database.\n   * **Don't forget it!** If you use a persistent datastore, no command (insert, find, update, remove) will be executed\n   * before it is called, so make sure to call it yourself or use the `autoload` option.\n   *\n   * Also, if loading fails, all commands registered to the {@link Datastore#executor} afterwards will not be executed.\n   * They will be registered and executed, in sequence, only after a successful loading.\n   *\n   * @param {object|string} options Can be an object or a string. If options is a string, the behavior is the same as in\n   * v0.6: it will be interpreted as `options.filename`. **Giving a string is deprecated, and will be removed in the\n   * next major version.**\n   * @param {string} [options.filename = null] Path to the file where the data is persisted. If left blank, the datastore is\n   * automatically considered in-memory only. It cannot end with a `~` which is used in the temporary files NeDB uses to\n   * perform crash-safe writes. Not used if `options.inMemoryOnly` is `true`.\n   * @param {boolean} [options.inMemoryOnly = false] If set to true, no data will be written in storage. This option has\n   * priority over `options.filename`.\n   * @param {object} [options.modes] Permissions to use for FS. Only used for Node.js storage module. Will not work on Windows.\n   * @param {number} [options.modes.fileMode = 0o644] Permissions to use for database files\n   * @param {number} [options.modes.dirMode = 0o755] Permissions to use for database directories\n   * @param {boolean} [options.timestampData = false] If set to true, createdAt and updatedAt will be created and\n   * populated automatically (if not specified by user)\n   * @param {boolean} [options.autoload = false] If used, the database will automatically be loaded from the datafile\n   * upon creation (you don't need to call `loadDatabase`). Any command issued before load is finished is buffered and\n   * will be executed when load is done. When autoloading is done, you can either use the `onload` callback, or you can\n   * use `this.autoloadPromise` which resolves (or rejects) when autloading is done.\n   * @param {NoParamCallback} [options.onload] If you use autoloading, this is the handler called after the `loadDatabase`. It\n   * takes one `error` argument. If you use autoloading without specifying this handler, and an error happens during\n   * load, an error will be thrown.\n   * @param {serializationHook} [options.beforeDeserialization] Hook you can use to transform data after it was serialized and\n   * before it is written to disk. Can be used for example to encrypt data before writing database to disk. This\n   * function takes a string as parameter (one line of an NeDB data file) and outputs the transformed string, **which\n   * must absolutely not contain a `\\n` character** (or data will be lost).\n   * @param {serializationHook} [options.afterSerialization] Inverse of `afterSerialization`. Make sure to include both and not\n   * just one, or you risk data loss. For the same reason, make sure both functions are inverses of one another. Some\n   * failsafe mechanisms are in place to prevent data loss if you misuse the serialization hooks: NeDB checks that never\n   * one is declared without the other, and checks that they are reverse of one another by testing on random strings of\n   * various lengths. In addition, if too much data is detected as corrupt, NeDB will refuse to start as it could mean\n   * you're not using the deserialization hook corresponding to the serialization hook used before.\n   * @param {number} [options.corruptAlertThreshold = 0.1] Between 0 and 1, defaults to 10%. NeDB will refuse to start\n   * if more than this percentage of the datafile is corrupt. 0 means you don't tolerate any corruption, 1 means you\n   * don't care.\n   * @param {compareStrings} [options.compareStrings] If specified, it overrides default string comparison which is not\n   * well adapted to non-US characters in particular accented letters. Native `localCompare` will most of the time be\n   * the right choice.\n   * @param {boolean} [options.testSerializationHooks=true] Whether to test the serialization hooks or not,\n   * might be CPU-intensive\n   */\n  constructor(options) {\n    super();\n    let filename;\n\n    // Retrocompatibility with v0.6 and before\n    if (typeof options === 'string') {\n      deprecate(() => {\n        filename = options;\n        this.inMemoryOnly = false; // Default\n      }, '@seald-io/nedb: Giving a string to the Datastore constructor is deprecated and will be removed in the next major version. Please use an options object with an argument \\'filename\\'.')();\n    } else {\n      options = options || {};\n      filename = options.filename;\n      /**\n       * Determines if the `Datastore` keeps data in-memory, or if it saves it in storage. Is not read after\n       * instanciation.\n       * @type {boolean}\n       * @protected\n       */\n      this.inMemoryOnly = options.inMemoryOnly || false;\n      /**\n       * Determines if the `Datastore` should autoload the database upon instantiation. Is not read after instanciation.\n       * @type {boolean}\n       * @protected\n       */\n      this.autoload = options.autoload || false;\n      /**\n       * Determines if the `Datastore` should add `createdAt` and `updatedAt` fields automatically if not set by the user.\n       * @type {boolean}\n       * @protected\n       */\n      this.timestampData = options.timestampData || false;\n    }\n\n    // Determine whether in memory or persistent\n    if (!filename || typeof filename !== 'string' || filename.length === 0) {\n      /**\n       * If null, it means `inMemoryOnly` is `true`. The `filename` is the name given to the storage module. Is not read\n       * after instanciation.\n       * @type {?string}\n       * @protected\n       */\n      this.filename = null;\n      this.inMemoryOnly = true;\n    } else {\n      this.filename = filename;\n    }\n\n    // String comparison function\n    /**\n     * Overrides default string comparison which is not well adapted to non-US characters in particular accented\n     * letters. Native `localCompare` will most of the time be the right choice\n     * @type {compareStrings}\n     * @function\n     * @protected\n     */\n    this.compareStrings = options.compareStrings;\n\n    // Persistence handling\n    /**\n     * The `Persistence` instance for this `Datastore`.\n     * @type {Persistence}\n     */\n    this.persistence = new Persistence({\n      db: this,\n      afterSerialization: options.afterSerialization,\n      beforeDeserialization: options.beforeDeserialization,\n      corruptAlertThreshold: options.corruptAlertThreshold,\n      modes: options.modes,\n      testSerializationHooks: options.testSerializationHooks\n    });\n\n    // This new executor is ready if we don't use persistence\n    // If we do, it will only be ready once loadDatabase is called\n    /**\n     * The `Executor` instance for this `Datastore`. It is used in all methods exposed by the {@link Datastore},\n     * any {@link Cursor} produced by the `Datastore` and by {@link Datastore#compactDatafileAsync} to ensure operations\n     * are performed sequentially in the database.\n     * @type {Executor}\n     * @protected\n     */\n    this.executor = new Executor();\n    if (this.inMemoryOnly) this.executor.ready = true;\n\n    /**\n     * Indexed by field name, dot notation can be used.\n     * _id is always indexed and since _ids are generated randomly the underlying binary search tree is always well-balanced\n     * @type {Object.<string, Index>}\n     * @protected\n     */\n    this.indexes = {};\n    this.indexes._id = new Index({\n      fieldName: '_id',\n      unique: true\n    });\n    /**\n     * Stores the time to live (TTL) of the indexes created. The key represents the field name, the value the number of\n     * seconds after which data with this index field should be removed.\n     * @type {Object.<string, number>}\n     * @protected\n     */\n    this.ttlIndexes = {};\n\n    // Queue a load of the database right away and call the onload handler\n    // By default (no onload handler), if there is an error there, no operation will be possible so warn the user by throwing an exception\n    if (this.autoload) {\n      /**\n       * A Promise that resolves when the autoload has finished.\n       *\n       * The onload callback is not awaited by this Promise, it is started immediately after that.\n       * @type {?Promise}\n       */\n      this.autoloadPromise = this.loadDatabaseAsync();\n      this.autoloadPromise.then(() => {\n        if (options.onload) options.onload();\n      }, err => {\n        if (options.onload) options.onload(err);else throw err;\n      });\n    } else this.autoloadPromise = null;\n    /**\n     * Interval if {@link Datastore#setAutocompactionInterval} was called.\n     * @private\n     * @type {null|number}\n     */\n    this._autocompactionIntervalId = null;\n  }\n\n  /**\n   * Queue a compaction/rewrite of the datafile.\n   * It works by rewriting the database file, and compacts it since the cache always contains only the number of\n   * documents in the collection while the data file is append-only so it may grow larger.\n   *\n   * @async\n   */\n  compactDatafileAsync() {\n    return this.executor.pushAsync(() => this.persistence.persistCachedDatabaseAsync());\n  }\n\n  /**\n   * Callback version of {@link Datastore#compactDatafileAsync}.\n   * @param {NoParamCallback} [callback = () => {}]\n   * @see Datastore#compactDatafileAsync\n   */\n  compactDatafile(callback) {\n    const promise = this.compactDatafileAsync();\n    if (typeof callback === 'function') callbackify(() => promise)(callback);\n  }\n\n  /**\n   * Set automatic compaction every `interval` ms\n   * @param {Number} interval in milliseconds, with an enforced minimum of 5000 milliseconds\n   */\n  setAutocompactionInterval(interval) {\n    const minInterval = 5000;\n    if (Number.isNaN(Number(interval))) throw new Error('Interval must be a non-NaN number');\n    const realInterval = Math.max(Number(interval), minInterval);\n    this.stopAutocompaction();\n    this._autocompactionIntervalId = setInterval(() => {\n      this.compactDatafile();\n    }, realInterval);\n  }\n\n  /**\n   * Stop autocompaction (do nothing if automatic compaction was not running)\n   */\n  stopAutocompaction() {\n    if (this._autocompactionIntervalId) {\n      clearInterval(this._autocompactionIntervalId);\n      this._autocompactionIntervalId = null;\n    }\n  }\n\n  /**\n   * Callback version of {@link Datastore#loadDatabaseAsync}.\n   * @param {NoParamCallback} [callback]\n   * @see Datastore#loadDatabaseAsync\n   */\n  loadDatabase(callback) {\n    const promise = this.loadDatabaseAsync();\n    if (typeof callback === 'function') callbackify(() => promise)(callback);\n  }\n\n  /**\n   * Stops auto-compaction, finishes all queued operations, drops the database both in memory and in storage.\n   * **WARNING**: it is not recommended re-using an instance of NeDB if its database has been dropped, it is\n   * preferable to instantiate a new one.\n   * @async\n   * @return {Promise}\n   */\n  dropDatabaseAsync() {\n    return this.persistence.dropDatabaseAsync(); // the executor is exceptionally used by Persistence\n  }\n\n  /**\n   * Callback version of {@link Datastore#dropDatabaseAsync}.\n   * @param {NoParamCallback} [callback]\n   * @see Datastore#dropDatabaseAsync\n   */\n  dropDatabase(callback) {\n    const promise = this.dropDatabaseAsync();\n    if (typeof callback === 'function') callbackify(() => promise)(callback);\n  }\n\n  /**\n   * Load the database from the datafile, and trigger the execution of buffered commands if any.\n   * @async\n   * @return {Promise}\n   */\n  loadDatabaseAsync() {\n    return this.executor.pushAsync(() => this.persistence.loadDatabaseAsync(), true);\n  }\n\n  /**\n   * Get an array of all the data in the database.\n   * @return {document[]}\n   */\n  getAllData() {\n    return this.indexes._id.getAll();\n  }\n\n  /**\n   * Reset all currently defined indexes.\n   * @param {?document|?document[]} [newData]\n   * @private\n   */\n  _resetIndexes(newData) {\n    for (const index of Object.values(this.indexes)) {\n      index.reset(newData);\n    }\n  }\n\n  /**\n   * Callback version of {@link Datastore#ensureIndex}.\n   * @param {object} options\n   * @param {string|string[]} options.fieldName\n   * @param {boolean} [options.unique = false]\n   * @param {boolean} [options.sparse = false]\n   * @param {number} [options.expireAfterSeconds]\n   * @param {NoParamCallback} [callback]\n   * @see Datastore#ensureIndex\n   */\n  ensureIndex(options = {}, callback) {\n    const promise = this.ensureIndexAsync(options); // to make sure the synchronous part of ensureIndexAsync is executed synchronously\n    if (typeof callback === 'function') callbackify(() => promise)(callback);\n  }\n\n  /**\n   * Ensure an index is kept for this field. Same parameters as lib/indexes\n   * This function acts synchronously on the indexes, however the persistence of the indexes is deferred with the\n   * executor.\n   * @param {object} options\n   * @param {string|string[]} options.fieldName Name of the field to index. Use the dot notation to index a field in a nested\n   * document. For a compound index, use an array of field names. Using a comma in a field name is not permitted.\n   * @param {boolean} [options.unique = false] Enforce field uniqueness. Note that a unique index will raise an error\n   * if you try to index two documents for which the field is not defined.\n   * @param {boolean} [options.sparse = false] Don't index documents for which the field is not defined. Use this option\n   * along with \"unique\" if you want to accept multiple documents for which it is not defined.\n   * @param {number} [options.expireAfterSeconds] - If set, the created index is a TTL (time to live) index, that will\n   * automatically remove documents when the system date becomes larger than the date on the indexed field plus\n   * `expireAfterSeconds`. Documents where the indexed field is not specified or not a `Date` object are ignored.\n   * @return {Promise<void>}\n   */\n  async ensureIndexAsync(options = {}) {\n    if (!options.fieldName) {\n      const err = new Error('Cannot create an index without a fieldName');\n      err.missingFieldName = true;\n      throw err;\n    }\n    const _fields = [].concat(options.fieldName).sort();\n    if (_fields.some(field => field.includes(','))) {\n      throw new Error('Cannot use comma in index fieldName');\n    }\n    const _options = {\n      ...options,\n      fieldName: _fields.join(',')\n    };\n    if (this.indexes[_options.fieldName]) return;\n    this.indexes[_options.fieldName] = new Index(_options);\n    if (options.expireAfterSeconds !== undefined) this.ttlIndexes[_options.fieldName] = _options.expireAfterSeconds; // With this implementation index creation is not necessary to ensure TTL but we stick with MongoDB's API here\n\n    try {\n      this.indexes[_options.fieldName].insert(this.getAllData());\n    } catch (e) {\n      delete this.indexes[_options.fieldName];\n      throw e;\n    }\n\n    // We may want to force all options to be persisted including defaults, not just the ones passed the index creation function\n    await this.executor.pushAsync(() => this.persistence.persistNewStateAsync([{\n      $$indexCreated: _options\n    }]), true);\n  }\n\n  /**\n   * Callback version of {@link Datastore#removeIndexAsync}.\n   * @param {string} fieldName\n   * @param {NoParamCallback} [callback]\n   * @see Datastore#removeIndexAsync\n   */\n  removeIndex(fieldName, callback = () => {}) {\n    const promise = this.removeIndexAsync(fieldName);\n    callbackify(() => promise)(callback);\n  }\n\n  /**\n   * Remove an index.\n   * @param {string} fieldName Field name of the index to remove. Use the dot notation to remove an index referring to a\n   * field in a nested document.\n   * @return {Promise<void>}\n   * @see Datastore#removeIndex\n   */\n  async removeIndexAsync(fieldName) {\n    delete this.indexes[fieldName];\n    await this.executor.pushAsync(() => this.persistence.persistNewStateAsync([{\n      $$indexRemoved: fieldName\n    }]), true);\n  }\n\n  /**\n   * Add one or several document(s) to all indexes.\n   *\n   * This is an internal function.\n   * @param {document} doc\n   * @private\n   */\n  _addToIndexes(doc) {\n    let failingIndex;\n    let error;\n    const keys = Object.keys(this.indexes);\n    for (let i = 0; i < keys.length; i += 1) {\n      try {\n        this.indexes[keys[i]].insert(doc);\n      } catch (e) {\n        failingIndex = i;\n        error = e;\n        break;\n      }\n    }\n\n    // If an error happened, we need to rollback the insert on all other indexes\n    if (error) {\n      for (let i = 0; i < failingIndex; i += 1) {\n        this.indexes[keys[i]].remove(doc);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Remove one or several document(s) from all indexes.\n   *\n   * This is an internal function.\n   * @param {document} doc\n   * @private\n   */\n  _removeFromIndexes(doc) {\n    for (const index of Object.values(this.indexes)) {\n      index.remove(doc);\n    }\n  }\n\n  /**\n   * Update one or several documents in all indexes.\n   *\n   * To update multiple documents, oldDoc must be an array of { oldDoc, newDoc } pairs.\n   *\n   * If one update violates a constraint, all changes are rolled back.\n   *\n   * This is an internal function.\n   * @param {document|Array.<{oldDoc: document, newDoc: document}>} oldDoc Document to update, or an `Array` of\n   * `{oldDoc, newDoc}` pairs.\n   * @param {document} [newDoc] Document to replace the oldDoc with. If the first argument is an `Array` of\n   * `{oldDoc, newDoc}` pairs, this second argument is ignored.\n   * @private\n   */\n  _updateIndexes(oldDoc, newDoc) {\n    let failingIndex;\n    let error;\n    const keys = Object.keys(this.indexes);\n    for (let i = 0; i < keys.length; i += 1) {\n      try {\n        this.indexes[keys[i]].update(oldDoc, newDoc);\n      } catch (e) {\n        failingIndex = i;\n        error = e;\n        break;\n      }\n    }\n\n    // If an error happened, we need to rollback the update on all other indexes\n    if (error) {\n      for (let i = 0; i < failingIndex; i += 1) {\n        this.indexes[keys[i]].revertUpdate(oldDoc, newDoc);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Get all candidate documents matching the query, regardless of their expiry status.\n   * @param {query} query\n   * @return {document[]}\n   *\n   * @private\n   */\n  _getRawCandidates(query) {\n    const indexNames = Object.keys(this.indexes);\n\n    // STEP 1: get candidates list by checking indexes from most to least frequent usecase\n    // For a basic match\n\n    let usableQuery;\n    usableQuery = Object.entries(query).filter(filterIndexNames(indexNames)).pop();\n    if (usableQuery) return this.indexes[usableQuery[0]].getMatching(usableQuery[1]);\n\n    // For a compound match\n    const compoundQueryKeys = indexNames.filter(indexName => indexName.indexOf(',') !== -1).map(indexName => indexName.split(',')).filter(subIndexNames => Object.entries(query).filter(filterIndexNames(subIndexNames)).length === subIndexNames.length);\n    if (compoundQueryKeys.length > 0) return this.indexes[compoundQueryKeys[0]].getMatching(pick(query, compoundQueryKeys[0]));\n\n    // For a $in match\n    usableQuery = Object.entries(query).filter(([k, v]) => !!(query[k] && Object.prototype.hasOwnProperty.call(query[k], '$in')) && indexNames.includes(k)).pop();\n    if (usableQuery) return this.indexes[usableQuery[0]].getMatching(usableQuery[1].$in);\n    // For a comparison match\n    usableQuery = Object.entries(query).filter(([k, v]) => !!(query[k] && (Object.prototype.hasOwnProperty.call(query[k], '$lt') || Object.prototype.hasOwnProperty.call(query[k], '$lte') || Object.prototype.hasOwnProperty.call(query[k], '$gt') || Object.prototype.hasOwnProperty.call(query[k], '$gte'))) && indexNames.includes(k)).pop();\n    if (usableQuery) return this.indexes[usableQuery[0]].getBetweenBounds(usableQuery[1]);\n    // By default, return all the DB data\n    return this.getAllData();\n  }\n\n  /**\n   * Return the list of candidates for a given query\n   * Crude implementation for now, we return the candidates given by the first usable index if any\n   * We try the following query types, in this order: basic match, $in match, comparison match\n   * One way to make it better would be to enable the use of multiple indexes if the first usable index\n   * returns too much data. I may do it in the future.\n   *\n   * Returned candidates will be scanned to find and remove all expired documents\n   *\n   * This is an internal function.\n   * @param {query} query\n   * @param {boolean} [dontExpireStaleDocs = false] If true don't remove stale docs. Useful for the remove function\n   * which shouldn't be impacted by expirations.\n   * @return {Promise<document[]>} candidates\n   * @private\n   */\n  async _getCandidatesAsync(query, dontExpireStaleDocs = false) {\n    const validDocs = [];\n\n    // STEP 1: get candidates list by checking indexes from most to least frequent usecase\n    const docs = this._getRawCandidates(query);\n    // STEP 2: remove all expired documents\n    if (!dontExpireStaleDocs) {\n      const expiredDocsIds = [];\n      const ttlIndexesFieldNames = Object.keys(this.ttlIndexes);\n      docs.forEach(doc => {\n        if (ttlIndexesFieldNames.every(i => !(doc[i] !== undefined && isDate(doc[i]) && Date.now() > doc[i].getTime() + this.ttlIndexes[i] * 1000))) validDocs.push(doc);else expiredDocsIds.push(doc._id);\n      });\n      for (const _id of expiredDocsIds) {\n        await this._removeAsync({\n          _id\n        }, {});\n      }\n    } else validDocs.push(...docs);\n    return validDocs;\n  }\n\n  /**\n   * Insert a new document\n   * This is an internal function, use {@link Datastore#insertAsync} which has the same signature.\n   * @param {document|document[]} newDoc\n   * @return {Promise<document|document[]>}\n   * @private\n   */\n  async _insertAsync(newDoc) {\n    const preparedDoc = this._prepareDocumentForInsertion(newDoc);\n    this._insertInCache(preparedDoc);\n    await this.persistence.persistNewStateAsync(Array.isArray(preparedDoc) ? preparedDoc : [preparedDoc]);\n    return model.deepCopy(preparedDoc);\n  }\n\n  /**\n   * Create a new _id that's not already in use\n   * @return {string} id\n   * @private\n   */\n  _createNewId() {\n    let attemptId = customUtils.uid(16);\n    // Try as many times as needed to get an unused _id. As explained in customUtils, the probability of this ever happening is extremely small, so this is O(1)\n    if (this.indexes._id.getMatching(attemptId).length > 0) attemptId = this._createNewId();\n    return attemptId;\n  }\n\n  /**\n   * Prepare a document (or array of documents) to be inserted in a database\n   * Meaning adds _id and timestamps if necessary on a copy of newDoc to avoid any side effect on user input\n   * @param {document|document[]} newDoc document, or Array of documents, to prepare\n   * @return {document|document[]} prepared document, or Array of prepared documents\n   * @private\n   */\n  _prepareDocumentForInsertion(newDoc) {\n    let preparedDoc;\n    if (Array.isArray(newDoc)) {\n      preparedDoc = [];\n      newDoc.forEach(doc => {\n        preparedDoc.push(this._prepareDocumentForInsertion(doc));\n      });\n    } else {\n      preparedDoc = model.deepCopy(newDoc);\n      if (preparedDoc._id === undefined) preparedDoc._id = this._createNewId();\n      const now = new Date();\n      if (this.timestampData && preparedDoc.createdAt === undefined) preparedDoc.createdAt = now;\n      if (this.timestampData && preparedDoc.updatedAt === undefined) preparedDoc.updatedAt = now;\n      model.checkObject(preparedDoc);\n    }\n    return preparedDoc;\n  }\n\n  /**\n   * If newDoc is an array of documents, this will insert all documents in the cache\n   * @param {document|document[]} preparedDoc\n   * @private\n   */\n  _insertInCache(preparedDoc) {\n    if (Array.isArray(preparedDoc)) this._insertMultipleDocsInCache(preparedDoc);else this._addToIndexes(preparedDoc);\n  }\n\n  /**\n   * If one insertion fails (e.g. because of a unique constraint), roll back all previous\n   * inserts and throws the error\n   * @param {document[]} preparedDocs\n   * @private\n   */\n  _insertMultipleDocsInCache(preparedDocs) {\n    let failingIndex;\n    let error;\n    for (let i = 0; i < preparedDocs.length; i += 1) {\n      try {\n        this._addToIndexes(preparedDocs[i]);\n      } catch (e) {\n        error = e;\n        failingIndex = i;\n        break;\n      }\n    }\n    if (error) {\n      for (let i = 0; i < failingIndex; i += 1) {\n        this._removeFromIndexes(preparedDocs[i]);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Callback version of {@link Datastore#insertAsync}.\n   * @param {document|document[]} newDoc\n   * @param {SingleDocumentCallback|MultipleDocumentsCallback} [callback]\n   * @see Datastore#insertAsync\n   */\n  insert(newDoc, callback) {\n    const promise = this.insertAsync(newDoc);\n    if (typeof callback === 'function') callbackify(() => promise)(callback);\n  }\n\n  /**\n   * Insert a new document, or new documents.\n   * @param {document|document[]} newDoc Document or array of documents to insert.\n   * @return {Promise<document|document[]>} The document(s) inserted.\n   * @async\n   */\n  insertAsync(newDoc) {\n    return this.executor.pushAsync(() => this._insertAsync(newDoc));\n  }\n\n  /**\n   * Callback for {@link Datastore#countCallback}.\n   * @callback Datastore~countCallback\n   * @param {?Error} err\n   * @param {?number} count\n   */\n\n  /**\n   * Callback-version of {@link Datastore#countAsync}.\n   * @param {query} query\n   * @param {Datastore~countCallback} [callback]\n   * @return {Cursor<number>|undefined}\n   * @see Datastore#countAsync\n   */\n  count(query, callback) {\n    const cursor = this.countAsync(query);\n    if (typeof callback === 'function') callbackify(cursor.execAsync.bind(cursor))(callback);else return cursor;\n  }\n\n  /**\n   * Count all documents matching the query.\n   * @param {query} query MongoDB-style query\n   * @return {Cursor<number>} count\n   * @async\n   */\n  countAsync(query) {\n    return new Cursor(this, query, docs => docs.length);\n  }\n\n  /**\n   * Callback version of {@link Datastore#findAsync}.\n   * @param {query} query\n   * @param {projection|MultipleDocumentsCallback} [projection = {}]\n   * @param {MultipleDocumentsCallback} [callback]\n   * @return {Cursor<document[]>|undefined}\n   * @see Datastore#findAsync\n   */\n  find(query, projection, callback) {\n    if (arguments.length === 1) {\n      projection = {};\n      // callback is undefined, will return a cursor\n    } else if (arguments.length === 2) {\n      if (typeof projection === 'function') {\n        callback = projection;\n        projection = {};\n      } // If not assume projection is an object and callback undefined\n    }\n    const cursor = this.findAsync(query, projection);\n    if (typeof callback === 'function') callbackify(cursor.execAsync.bind(cursor))(callback);else return cursor;\n  }\n\n  /**\n   * Find all documents matching the query.\n   * We return the {@link Cursor} that the user can either `await` directly or use to can {@link Cursor#limit} or\n   * {@link Cursor#skip} before.\n   * @param {query} query MongoDB-style query\n   * @param {projection} [projection = {}] MongoDB-style projection\n   * @return {Cursor<document[]>}\n   * @async\n   */\n  findAsync(query, projection = {}) {\n    const cursor = new Cursor(this, query, docs => docs.map(doc => model.deepCopy(doc)));\n    cursor.projection(projection);\n    return cursor;\n  }\n\n  /**\n   * @callback Datastore~findOneCallback\n   * @param {?Error} err\n   * @param {document} doc\n   */\n\n  /**\n   * Callback version of {@link Datastore#findOneAsync}.\n   * @param {query} query\n   * @param {projection|SingleDocumentCallback} [projection = {}]\n   * @param {SingleDocumentCallback} [callback]\n   * @return {Cursor<document>|undefined}\n   * @see Datastore#findOneAsync\n   */\n  findOne(query, projection, callback) {\n    if (arguments.length === 1) {\n      projection = {};\n      // callback is undefined, will return a cursor\n    } else if (arguments.length === 2) {\n      if (typeof projection === 'function') {\n        callback = projection;\n        projection = {};\n      } // If not assume projection is an object and callback undefined\n    }\n    const cursor = this.findOneAsync(query, projection);\n    if (typeof callback === 'function') callbackify(cursor.execAsync.bind(cursor))(callback);else return cursor;\n  }\n\n  /**\n   * Find one document matching the query.\n   * We return the {@link Cursor} that the user can either `await` directly or use to can {@link Cursor#skip} before.\n   * @param {query} query MongoDB-style query\n   * @param {projection} projection MongoDB-style projection\n   * @return {Cursor<document>}\n   */\n  findOneAsync(query, projection = {}) {\n    const cursor = new Cursor(this, query, docs => docs.length === 1 ? model.deepCopy(docs[0]) : null);\n    cursor.projection(projection).limit(1);\n    return cursor;\n  }\n\n  /**\n   * See {@link Datastore#updateAsync} return type for the definition of the callback parameters.\n   *\n   * **WARNING:** Prior to 3.0.0, `upsert` was either `true` of falsy (but not `false`), it is now always a boolean.\n   * `affectedDocuments` could be `undefined` when `returnUpdatedDocs` was `false`, it is now `null` in these cases.\n   *\n   * **WARNING:** Prior to 1.8.0, the `upsert` argument was not given, it was impossible for the developer to determine\n   * during a `{ multi: false, returnUpdatedDocs: true, upsert: true }` update if it inserted a document or just updated\n   * it.\n   *\n   * @callback Datastore~updateCallback\n   * @param {?Error} err\n   * @param {number} numAffected\n   * @param {?document[]|?document} affectedDocuments\n   * @param {boolean} upsert\n   * @see {Datastore#updateAsync}\n   */\n\n  /**\n   * Version without the using {@link Datastore~executor} of {@link Datastore#updateAsync}, use it instead.\n   *\n   * @param {query} query\n   * @param {document|update} update\n   * @param {Object} options\n   * @param {boolean} [options.multi = false]\n   * @param {boolean} [options.upsert = false]\n   * @param {boolean} [options.returnUpdatedDocs = false]\n   * @return {Promise<{numAffected: number, affectedDocuments: document[]|document|null, upsert: boolean}>}\n   * @private\n   * @see Datastore#updateAsync\n   */\n  async _updateAsync(query, update, options) {\n    const multi = options.multi !== undefined ? options.multi : false;\n    const upsert = options.upsert !== undefined ? options.upsert : false;\n\n    // If upsert option is set, check whether we need to insert the doc\n    if (upsert) {\n      const cursor = new Cursor(this, query);\n\n      // Need to use an internal function not tied to the executor to avoid deadlock\n      const docs = await cursor.limit(1)._execAsync();\n      if (docs.length !== 1) {\n        let toBeInserted;\n        try {\n          model.checkObject(update);\n          // updateQuery is a simple object with no modifier, use it as the document to insert\n          toBeInserted = update;\n        } catch (e) {\n          // updateQuery contains modifiers, use the find query as the base,\n          // strip it from all operators and update it according to updateQuery\n          toBeInserted = model.modify(model.deepCopy(query, true), update);\n        }\n        const newDoc = await this._insertAsync(toBeInserted);\n        return {\n          numAffected: 1,\n          affectedDocuments: newDoc,\n          upsert: true\n        };\n      }\n    }\n    // Perform the update\n    let numReplaced = 0;\n    let modifiedDoc;\n    const modifications = [];\n    let createdAt;\n    const candidates = await this._getCandidatesAsync(query);\n    // Preparing update (if an error is thrown here neither the datafile nor\n    // the in-memory indexes are affected)\n    for (const candidate of candidates) {\n      if (model.match(candidate, query) && (multi || numReplaced === 0)) {\n        numReplaced += 1;\n        if (this.timestampData) {\n          createdAt = candidate.createdAt;\n        }\n        modifiedDoc = model.modify(candidate, update);\n        if (this.timestampData) {\n          modifiedDoc.createdAt = createdAt;\n          modifiedDoc.updatedAt = new Date();\n        }\n        modifications.push({\n          oldDoc: candidate,\n          newDoc: modifiedDoc\n        });\n      }\n    }\n\n    // Change the docs in memory\n    this._updateIndexes(modifications);\n\n    // Update the datafile\n    const updatedDocs = modifications.map(x => x.newDoc);\n    await this.persistence.persistNewStateAsync(updatedDocs);\n    if (!options.returnUpdatedDocs) return {\n      numAffected: numReplaced,\n      upsert: false,\n      affectedDocuments: null\n    };else {\n      let updatedDocsDC = [];\n      updatedDocs.forEach(doc => {\n        updatedDocsDC.push(model.deepCopy(doc));\n      });\n      if (!multi) updatedDocsDC = updatedDocsDC[0];\n      return {\n        numAffected: numReplaced,\n        affectedDocuments: updatedDocsDC,\n        upsert: false\n      };\n    }\n  }\n\n  /**\n   * Callback version of {@link Datastore#updateAsync}.\n   * @param {query} query\n   * @param {document|*} update\n   * @param {Object|Datastore~updateCallback} [options|]\n   * @param {boolean} [options.multi = false]\n   * @param {boolean} [options.upsert = false]\n   * @param {boolean} [options.returnUpdatedDocs = false]\n   * @param {Datastore~updateCallback} [callback]\n   * @see Datastore#updateAsync\n   *\n   */\n  update(query, update, options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n    const _callback = (err, res = {}) => {\n      if (callback) callback(err, res.numAffected, res.affectedDocuments, res.upsert);\n    };\n    callbackify((query, update, options) => this.updateAsync(query, update, options))(query, update, options, _callback);\n  }\n\n  /**\n   * Update all docs matching query.\n   * @param {query} query is the same kind of finding query you use with `find` and `findOne`.\n   * @param {document|*} update specifies how the documents should be modified. It is either a new document or a\n   * set of modifiers (you cannot use both together, it doesn't make sense!). Using a new document will replace the\n   * matched docs. Using a set of modifiers will create the fields they need to modify if they don't exist, and you can\n   * apply them to subdocs. Available field modifiers are `$set` to change a field's value, `$unset` to delete a field,\n   * `$inc` to increment a field's value and `$min`/`$max` to change field's value, only if provided value is\n   * less/greater than current value. To work on arrays, you have `$push`, `$pop`, `$addToSet`, `$pull`, and the special\n   * `$each` and `$slice`.\n   * @param {Object} [options = {}] Optional options\n   * @param {boolean} [options.multi = false] If true, can update multiple documents\n   * @param {boolean} [options.upsert = false] If true, can insert a new document corresponding to the `update` rules if\n   * your `query` doesn't match anything. If your `update` is a simple object with no modifiers, it is the inserted\n   * document. In the other case, the `query` is stripped from all operator recursively, and the `update` is applied to\n   * it.\n   * @param {boolean} [options.returnUpdatedDocs = false] (not Mongo-DB compatible) If true and update is not an upsert,\n   * will return the array of documents matched by the find query and updated. Updated documents will be returned even\n   * if the update did not actually modify them.\n   * @return {Promise<{numAffected: number, affectedDocuments: document[]|document|null, upsert: boolean}>}\n   * - `upsert` is `true` if and only if the update did insert a document, **cannot be true if `options.upsert !== true`**.\n   * - `numAffected` is the number of documents affected by the update or insertion (if `options.multi` is `false` or `options.upsert` is `true`, cannot exceed `1`);\n   * - `affectedDocuments` can be one of the following:\n   *    - If `upsert` is `true`, the inserted document;\n   *    - If `options.returnUpdatedDocs` is `false`, `null`;\n   *    - If `options.returnUpdatedDocs` is `true`:\n   *      - If `options.multi` is `false`, the updated document;\n   *      - If `options.multi` is `true`, the array of updated documents.\n   * @async\n   */\n  updateAsync(query, update, options = {}) {\n    return this.executor.pushAsync(() => this._updateAsync(query, update, options));\n  }\n\n  /**\n   * @callback Datastore~removeCallback\n   * @param {?Error} err\n   * @param {?number} numRemoved\n   */\n\n  /**\n   * Internal version without using the {@link Datastore#executor} of {@link Datastore#removeAsync}, use it instead.\n   *\n   * @param {query} query\n   * @param {object} [options]\n   * @param {boolean} [options.multi = false]\n   * @return {Promise<number>}\n   * @private\n   * @see Datastore#removeAsync\n   */\n  async _removeAsync(query, options = {}) {\n    const multi = options.multi !== undefined ? options.multi : false;\n    const candidates = await this._getCandidatesAsync(query, true);\n    const removedDocs = [];\n    let numRemoved = 0;\n    candidates.forEach(d => {\n      if (model.match(d, query) && (multi || numRemoved === 0)) {\n        numRemoved += 1;\n        removedDocs.push({\n          $$deleted: true,\n          _id: d._id\n        });\n        this._removeFromIndexes(d);\n      }\n    });\n    await this.persistence.persistNewStateAsync(removedDocs);\n    return numRemoved;\n  }\n\n  /**\n   * Callback version of {@link Datastore#removeAsync}.\n   * @param {query} query\n   * @param {object|Datastore~removeCallback} [options={}]\n   * @param {boolean} [options.multi = false]\n   * @param {Datastore~removeCallback} [cb = () => {}]\n   * @see Datastore#removeAsync\n   */\n  remove(query, options, cb) {\n    if (typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n    const callback = cb || (() => {});\n    callbackify((query, options) => this.removeAsync(query, options))(query, options, callback);\n  }\n\n  /**\n   * Remove all docs matching the query.\n   * @param {query} query MongoDB-style query\n   * @param {object} [options={}] Optional options\n   * @param {boolean} [options.multi = false] If true, can update multiple documents\n   * @return {Promise<number>} How many documents were removed\n   * @async\n   */\n  removeAsync(query, options = {}) {\n    return this.executor.pushAsync(() => this._removeAsync(query, options));\n  }\n}\nmodule.exports = Datastore;","map":{"version":3,"names":["EventEmitter","require","callbackify","deprecate","Cursor","customUtils","Executor","Index","model","Persistence","isDate","pick","filterIndexNames","Datastore","constructor","options","filename","inMemoryOnly","autoload","timestampData","length","compareStrings","persistence","db","afterSerialization","beforeDeserialization","corruptAlertThreshold","modes","testSerializationHooks","executor","ready","indexes","_id","fieldName","unique","ttlIndexes","autoloadPromise","loadDatabaseAsync","then","onload","err","_autocompactionIntervalId","compactDatafileAsync","pushAsync","persistCachedDatabaseAsync","compactDatafile","callback","promise","setAutocompactionInterval","interval","minInterval","Number","isNaN","Error","realInterval","Math","max","stopAutocompaction","setInterval","clearInterval","loadDatabase","dropDatabaseAsync","dropDatabase","getAllData","getAll","_resetIndexes","newData","index","Object","values","reset","ensureIndex","ensureIndexAsync","missingFieldName","_fields","concat","sort","some","field","includes","_options","join","expireAfterSeconds","undefined","insert","e","persistNewStateAsync","$$indexCreated","removeIndex","removeIndexAsync","$$indexRemoved","_addToIndexes","doc","failingIndex","error","keys","i","remove","_removeFromIndexes","_updateIndexes","oldDoc","newDoc","update","revertUpdate","_getRawCandidates","query","indexNames","usableQuery","entries","filter","pop","getMatching","compoundQueryKeys","indexName","indexOf","map","split","subIndexNames","k","v","prototype","hasOwnProperty","call","$in","getBetweenBounds","_getCandidatesAsync","dontExpireStaleDocs","validDocs","docs","expiredDocsIds","ttlIndexesFieldNames","forEach","every","Date","now","getTime","push","_removeAsync","_insertAsync","preparedDoc","_prepareDocumentForInsertion","_insertInCache","Array","isArray","deepCopy","_createNewId","attemptId","uid","createdAt","updatedAt","checkObject","_insertMultipleDocsInCache","preparedDocs","insertAsync","count","cursor","countAsync","execAsync","bind","find","projection","arguments","findAsync","findOne","findOneAsync","limit","_updateAsync","multi","upsert","_execAsync","toBeInserted","modify","numAffected","affectedDocuments","numReplaced","modifiedDoc","modifications","candidates","candidate","match","updatedDocs","x","returnUpdatedDocs","updatedDocsDC","_callback","res","updateAsync","removedDocs","numRemoved","d","$$deleted","cb","removeAsync","module","exports"],"sources":["C:/Users/benit/Music/arbisout/node_modules/@seald-io/nedb/lib/datastore.js"],"sourcesContent":["const { EventEmitter } = require('events')\nconst { callbackify, deprecate } = require('util')\nconst Cursor = require('./cursor.js')\nconst customUtils = require('./customUtils.js')\nconst Executor = require('./executor.js')\nconst Index = require('./indexes.js')\nconst model = require('./model.js')\nconst Persistence = require('./persistence.js')\nconst { isDate, pick, filterIndexNames } = require('./utils.js')\n\n/**\n * Callback with no parameter\n * @callback NoParamCallback\n * @param {?Error} err\n */\n\n/**\n * String comparison function.\n * ```\n *   if (a < b) return -1\n *   if (a > b) return 1\n *   return 0\n * ```\n * @callback compareStrings\n * @param {string} a\n * @param {string} b\n * @return {number}\n */\n\n/**\n * Callback that returns an Array of documents.\n * @callback MultipleDocumentsCallback\n * @param {?Error} err\n * @param {?document[]} docs\n */\n\n/**\n * Callback that returns a single document.\n * @callback SingleDocumentCallback\n * @param {?Error} err\n * @param {?document} docs\n */\n\n/**\n * Generic async function.\n * @callback AsyncFunction\n * @param {...*} args\n * @return {Promise<*>}\n */\n\n/**\n * Callback with generic parameters.\n * @callback GenericCallback\n * @param {?Error} err\n * @param {...*} args\n */\n\n/**\n * Compaction event. Happens when the Datastore's Persistence has been compacted.\n * It happens when calling {@link Datastore#compactDatafileAsync}, which is called periodically if you have called\n * {@link Datastore#setAutocompactionInterval}.\n *\n * @event Datastore#event:\"compaction.done\"\n * @type {undefined}\n */\n\n/**\n * Generic document in NeDB.\n * It consists of an Object with anything you want inside.\n * @typedef document\n * @property {?string} [_id] Internal `_id` of the document, which can be `null` or undefined at some points (when not\n * inserted yet for example).\n * @type {object}\n */\n\n/**\n * Nedb query.\n *\n * Each key of a query references a field name, which can use the dot-notation to reference subfields inside nested\n * documents, arrays, arrays of subdocuments and to match a specific element of an array.\n *\n * Each value of a query can be one of the following:\n * - `string`: matches all documents which have this string as value for the referenced field name\n * - `number`: matches all documents which have this number as value for the referenced field name\n * - `Regexp`: matches all documents which have a value that matches the given `Regexp` for the referenced field name\n * - `object`: matches all documents which have this object as deep-value for the referenced field name\n * - Comparison operators: the syntax is `{ field: { $op: value } }` where `$op` is any comparison operator:\n *   - `$lt`, `$lte`: less than, less than or equal\n *   - `$gt`, `$gte`: greater than, greater than or equal\n *   - `$in`: member of. `value` must be an array of values\n *   - `$ne`, `$nin`: not equal, not a member of\n *   - `$exists`: checks whether the document posses the property `field`. `value` should be true or false\n *   - `$regex`: checks whether a string is matched by the regular expression. Contrary to MongoDB, the use of\n *   `$options` with `$regex` is not supported, because it doesn't give you more power than regex flags. Basic\n *   queries are more readable so only use the `$regex` operator when you need to use another operator with it\n *   - `$size`: if the referenced filed is an Array, matches on the size of the array\n *   - `$elemMatch`: matches if at least one array element matches the sub-query entirely\n * - Logical operators: You can combine queries using logical operators:\n *   - For `$or` and `$and`, the syntax is `{ $op: [query1, query2, ...] }`.\n *   - For `$not`, the syntax is `{ $not: query }`\n *   - For `$where`, the syntax is:\n *   ```\n *   { $where: function () {\n *     // object is 'this'\n *     // return a boolean\n *   } }\n *   ```\n * @typedef query\n * @type {Object.<string, *>}\n */\n\n/**\n * Nedb projection.\n *\n * You can give `find` and `findOne` an optional second argument, `projections`.\n * The syntax is the same as MongoDB: `{ a: 1, b: 1 }` to return only the `a`\n * and `b` fields, `{ a: 0, b: 0 }` to omit these two fields. You cannot use both\n * modes at the time, except for `_id` which is by default always returned and\n * which you can choose to omit. You can project on nested documents.\n *\n * To reference subfields, you can use the dot-notation.\n *\n * @typedef projection\n * @type {Object.<string, 0|1>}\n */\n\n/**\n * The `beforeDeserialization` and `afterSerialization` callbacks are hooks which are executed respectively before\n * parsing each document and after stringifying them. They can be used for example to encrypt the Datastore.\n * The `beforeDeserialization` should revert what `afterSerialization` has done.\n * @callback serializationHook\n * @param {string} x\n * @return {string|Promise<string>}\n */\n\n/**\n * @external EventEmitter\n * @see http://nodejs.org/api/events.html\n */\n\n/**\n * @class\n * @classdesc The `Datastore` class is the main class of NeDB.\n * @extends external:EventEmitter\n * @emits Datastore#event:\"compaction.done\"\n * @typicalname NeDB\n */\nclass Datastore extends EventEmitter {\n  /**\n   * Create a new collection, either persistent or in-memory.\n   *\n   * If you use a persistent datastore without the `autoload` option, you need to call {@link Datastore#loadDatabase} or\n   * {@link Datastore#loadDatabaseAsync} manually. This function fetches the data from datafile and prepares the database.\n   * **Don't forget it!** If you use a persistent datastore, no command (insert, find, update, remove) will be executed\n   * before it is called, so make sure to call it yourself or use the `autoload` option.\n   *\n   * Also, if loading fails, all commands registered to the {@link Datastore#executor} afterwards will not be executed.\n   * They will be registered and executed, in sequence, only after a successful loading.\n   *\n   * @param {object|string} options Can be an object or a string. If options is a string, the behavior is the same as in\n   * v0.6: it will be interpreted as `options.filename`. **Giving a string is deprecated, and will be removed in the\n   * next major version.**\n   * @param {string} [options.filename = null] Path to the file where the data is persisted. If left blank, the datastore is\n   * automatically considered in-memory only. It cannot end with a `~` which is used in the temporary files NeDB uses to\n   * perform crash-safe writes. Not used if `options.inMemoryOnly` is `true`.\n   * @param {boolean} [options.inMemoryOnly = false] If set to true, no data will be written in storage. This option has\n   * priority over `options.filename`.\n   * @param {object} [options.modes] Permissions to use for FS. Only used for Node.js storage module. Will not work on Windows.\n   * @param {number} [options.modes.fileMode = 0o644] Permissions to use for database files\n   * @param {number} [options.modes.dirMode = 0o755] Permissions to use for database directories\n   * @param {boolean} [options.timestampData = false] If set to true, createdAt and updatedAt will be created and\n   * populated automatically (if not specified by user)\n   * @param {boolean} [options.autoload = false] If used, the database will automatically be loaded from the datafile\n   * upon creation (you don't need to call `loadDatabase`). Any command issued before load is finished is buffered and\n   * will be executed when load is done. When autoloading is done, you can either use the `onload` callback, or you can\n   * use `this.autoloadPromise` which resolves (or rejects) when autloading is done.\n   * @param {NoParamCallback} [options.onload] If you use autoloading, this is the handler called after the `loadDatabase`. It\n   * takes one `error` argument. If you use autoloading without specifying this handler, and an error happens during\n   * load, an error will be thrown.\n   * @param {serializationHook} [options.beforeDeserialization] Hook you can use to transform data after it was serialized and\n   * before it is written to disk. Can be used for example to encrypt data before writing database to disk. This\n   * function takes a string as parameter (one line of an NeDB data file) and outputs the transformed string, **which\n   * must absolutely not contain a `\\n` character** (or data will be lost).\n   * @param {serializationHook} [options.afterSerialization] Inverse of `afterSerialization`. Make sure to include both and not\n   * just one, or you risk data loss. For the same reason, make sure both functions are inverses of one another. Some\n   * failsafe mechanisms are in place to prevent data loss if you misuse the serialization hooks: NeDB checks that never\n   * one is declared without the other, and checks that they are reverse of one another by testing on random strings of\n   * various lengths. In addition, if too much data is detected as corrupt, NeDB will refuse to start as it could mean\n   * you're not using the deserialization hook corresponding to the serialization hook used before.\n   * @param {number} [options.corruptAlertThreshold = 0.1] Between 0 and 1, defaults to 10%. NeDB will refuse to start\n   * if more than this percentage of the datafile is corrupt. 0 means you don't tolerate any corruption, 1 means you\n   * don't care.\n   * @param {compareStrings} [options.compareStrings] If specified, it overrides default string comparison which is not\n   * well adapted to non-US characters in particular accented letters. Native `localCompare` will most of the time be\n   * the right choice.\n   * @param {boolean} [options.testSerializationHooks=true] Whether to test the serialization hooks or not,\n   * might be CPU-intensive\n   */\n  constructor (options) {\n    super()\n    let filename\n\n    // Retrocompatibility with v0.6 and before\n    if (typeof options === 'string') {\n      deprecate(() => {\n        filename = options\n        this.inMemoryOnly = false // Default\n      }, '@seald-io/nedb: Giving a string to the Datastore constructor is deprecated and will be removed in the next major version. Please use an options object with an argument \\'filename\\'.')()\n    } else {\n      options = options || {}\n      filename = options.filename\n      /**\n       * Determines if the `Datastore` keeps data in-memory, or if it saves it in storage. Is not read after\n       * instanciation.\n       * @type {boolean}\n       * @protected\n       */\n      this.inMemoryOnly = options.inMemoryOnly || false\n      /**\n       * Determines if the `Datastore` should autoload the database upon instantiation. Is not read after instanciation.\n       * @type {boolean}\n       * @protected\n       */\n      this.autoload = options.autoload || false\n      /**\n       * Determines if the `Datastore` should add `createdAt` and `updatedAt` fields automatically if not set by the user.\n       * @type {boolean}\n       * @protected\n       */\n      this.timestampData = options.timestampData || false\n    }\n\n    // Determine whether in memory or persistent\n    if (!filename || typeof filename !== 'string' || filename.length === 0) {\n      /**\n       * If null, it means `inMemoryOnly` is `true`. The `filename` is the name given to the storage module. Is not read\n       * after instanciation.\n       * @type {?string}\n       * @protected\n       */\n      this.filename = null\n      this.inMemoryOnly = true\n    } else {\n      this.filename = filename\n    }\n\n    // String comparison function\n    /**\n     * Overrides default string comparison which is not well adapted to non-US characters in particular accented\n     * letters. Native `localCompare` will most of the time be the right choice\n     * @type {compareStrings}\n     * @function\n     * @protected\n     */\n    this.compareStrings = options.compareStrings\n\n    // Persistence handling\n    /**\n     * The `Persistence` instance for this `Datastore`.\n     * @type {Persistence}\n     */\n    this.persistence = new Persistence({\n      db: this,\n      afterSerialization: options.afterSerialization,\n      beforeDeserialization: options.beforeDeserialization,\n      corruptAlertThreshold: options.corruptAlertThreshold,\n      modes: options.modes,\n      testSerializationHooks: options.testSerializationHooks\n    })\n\n    // This new executor is ready if we don't use persistence\n    // If we do, it will only be ready once loadDatabase is called\n    /**\n     * The `Executor` instance for this `Datastore`. It is used in all methods exposed by the {@link Datastore},\n     * any {@link Cursor} produced by the `Datastore` and by {@link Datastore#compactDatafileAsync} to ensure operations\n     * are performed sequentially in the database.\n     * @type {Executor}\n     * @protected\n     */\n    this.executor = new Executor()\n    if (this.inMemoryOnly) this.executor.ready = true\n\n    /**\n     * Indexed by field name, dot notation can be used.\n     * _id is always indexed and since _ids are generated randomly the underlying binary search tree is always well-balanced\n     * @type {Object.<string, Index>}\n     * @protected\n     */\n    this.indexes = {}\n    this.indexes._id = new Index({ fieldName: '_id', unique: true })\n    /**\n     * Stores the time to live (TTL) of the indexes created. The key represents the field name, the value the number of\n     * seconds after which data with this index field should be removed.\n     * @type {Object.<string, number>}\n     * @protected\n     */\n    this.ttlIndexes = {}\n\n    // Queue a load of the database right away and call the onload handler\n    // By default (no onload handler), if there is an error there, no operation will be possible so warn the user by throwing an exception\n    if (this.autoload) {\n      /**\n       * A Promise that resolves when the autoload has finished.\n       *\n       * The onload callback is not awaited by this Promise, it is started immediately after that.\n       * @type {?Promise}\n       */\n      this.autoloadPromise = this.loadDatabaseAsync()\n      this.autoloadPromise\n        .then(() => {\n          if (options.onload) options.onload()\n        }, err => {\n          if (options.onload) options.onload(err)\n          else throw err\n        })\n    } else this.autoloadPromise = null\n    /**\n     * Interval if {@link Datastore#setAutocompactionInterval} was called.\n     * @private\n     * @type {null|number}\n     */\n    this._autocompactionIntervalId = null\n  }\n\n  /**\n   * Queue a compaction/rewrite of the datafile.\n   * It works by rewriting the database file, and compacts it since the cache always contains only the number of\n   * documents in the collection while the data file is append-only so it may grow larger.\n   *\n   * @async\n   */\n  compactDatafileAsync () {\n    return this.executor.pushAsync(() => this.persistence.persistCachedDatabaseAsync())\n  }\n\n  /**\n   * Callback version of {@link Datastore#compactDatafileAsync}.\n   * @param {NoParamCallback} [callback = () => {}]\n   * @see Datastore#compactDatafileAsync\n   */\n  compactDatafile (callback) {\n    const promise = this.compactDatafileAsync()\n    if (typeof callback === 'function') callbackify(() => promise)(callback)\n  }\n\n  /**\n   * Set automatic compaction every `interval` ms\n   * @param {Number} interval in milliseconds, with an enforced minimum of 5000 milliseconds\n   */\n  setAutocompactionInterval (interval) {\n    const minInterval = 5000\n    if (Number.isNaN(Number(interval))) throw new Error('Interval must be a non-NaN number')\n    const realInterval = Math.max(Number(interval), minInterval)\n\n    this.stopAutocompaction()\n\n    this._autocompactionIntervalId = setInterval(() => {\n      this.compactDatafile()\n    }, realInterval)\n  }\n\n  /**\n   * Stop autocompaction (do nothing if automatic compaction was not running)\n   */\n  stopAutocompaction () {\n    if (this._autocompactionIntervalId) {\n      clearInterval(this._autocompactionIntervalId)\n      this._autocompactionIntervalId = null\n    }\n  }\n\n  /**\n   * Callback version of {@link Datastore#loadDatabaseAsync}.\n   * @param {NoParamCallback} [callback]\n   * @see Datastore#loadDatabaseAsync\n   */\n  loadDatabase (callback) {\n    const promise = this.loadDatabaseAsync()\n    if (typeof callback === 'function') callbackify(() => promise)(callback)\n  }\n\n  /**\n   * Stops auto-compaction, finishes all queued operations, drops the database both in memory and in storage.\n   * **WARNING**: it is not recommended re-using an instance of NeDB if its database has been dropped, it is\n   * preferable to instantiate a new one.\n   * @async\n   * @return {Promise}\n   */\n  dropDatabaseAsync () {\n    return this.persistence.dropDatabaseAsync() // the executor is exceptionally used by Persistence\n  }\n\n  /**\n   * Callback version of {@link Datastore#dropDatabaseAsync}.\n   * @param {NoParamCallback} [callback]\n   * @see Datastore#dropDatabaseAsync\n   */\n  dropDatabase (callback) {\n    const promise = this.dropDatabaseAsync()\n    if (typeof callback === 'function') callbackify(() => promise)(callback)\n  }\n\n  /**\n   * Load the database from the datafile, and trigger the execution of buffered commands if any.\n   * @async\n   * @return {Promise}\n   */\n  loadDatabaseAsync () {\n    return this.executor.pushAsync(() => this.persistence.loadDatabaseAsync(), true)\n  }\n\n  /**\n   * Get an array of all the data in the database.\n   * @return {document[]}\n   */\n  getAllData () {\n    return this.indexes._id.getAll()\n  }\n\n  /**\n   * Reset all currently defined indexes.\n   * @param {?document|?document[]} [newData]\n   * @private\n   */\n  _resetIndexes (newData) {\n    for (const index of Object.values(this.indexes)) {\n      index.reset(newData)\n    }\n  }\n\n  /**\n   * Callback version of {@link Datastore#ensureIndex}.\n   * @param {object} options\n   * @param {string|string[]} options.fieldName\n   * @param {boolean} [options.unique = false]\n   * @param {boolean} [options.sparse = false]\n   * @param {number} [options.expireAfterSeconds]\n   * @param {NoParamCallback} [callback]\n   * @see Datastore#ensureIndex\n   */\n  ensureIndex (options = {}, callback) {\n    const promise = this.ensureIndexAsync(options) // to make sure the synchronous part of ensureIndexAsync is executed synchronously\n    if (typeof callback === 'function') callbackify(() => promise)(callback)\n  }\n\n  /**\n   * Ensure an index is kept for this field. Same parameters as lib/indexes\n   * This function acts synchronously on the indexes, however the persistence of the indexes is deferred with the\n   * executor.\n   * @param {object} options\n   * @param {string|string[]} options.fieldName Name of the field to index. Use the dot notation to index a field in a nested\n   * document. For a compound index, use an array of field names. Using a comma in a field name is not permitted.\n   * @param {boolean} [options.unique = false] Enforce field uniqueness. Note that a unique index will raise an error\n   * if you try to index two documents for which the field is not defined.\n   * @param {boolean} [options.sparse = false] Don't index documents for which the field is not defined. Use this option\n   * along with \"unique\" if you want to accept multiple documents for which it is not defined.\n   * @param {number} [options.expireAfterSeconds] - If set, the created index is a TTL (time to live) index, that will\n   * automatically remove documents when the system date becomes larger than the date on the indexed field plus\n   * `expireAfterSeconds`. Documents where the indexed field is not specified or not a `Date` object are ignored.\n   * @return {Promise<void>}\n   */\n  async ensureIndexAsync (options = {}) {\n    if (!options.fieldName) {\n      const err = new Error('Cannot create an index without a fieldName')\n      err.missingFieldName = true\n      throw err\n    }\n\n    const _fields = [].concat(options.fieldName).sort()\n\n    if (_fields.some(field => field.includes(','))) {\n      throw new Error('Cannot use comma in index fieldName')\n    }\n\n    const _options = {\n      ...options,\n      fieldName: _fields.join(',')\n    }\n\n    if (this.indexes[_options.fieldName]) return\n\n    this.indexes[_options.fieldName] = new Index(_options)\n    if (options.expireAfterSeconds !== undefined) this.ttlIndexes[_options.fieldName] = _options.expireAfterSeconds // With this implementation index creation is not necessary to ensure TTL but we stick with MongoDB's API here\n\n    try {\n      this.indexes[_options.fieldName].insert(this.getAllData())\n    } catch (e) {\n      delete this.indexes[_options.fieldName]\n      throw e\n    }\n\n    // We may want to force all options to be persisted including defaults, not just the ones passed the index creation function\n    await this.executor.pushAsync(() => this.persistence.persistNewStateAsync([{ $$indexCreated: _options }]), true)\n  }\n\n  /**\n   * Callback version of {@link Datastore#removeIndexAsync}.\n   * @param {string} fieldName\n   * @param {NoParamCallback} [callback]\n   * @see Datastore#removeIndexAsync\n   */\n  removeIndex (fieldName, callback = () => {}) {\n    const promise = this.removeIndexAsync(fieldName)\n    callbackify(() => promise)(callback)\n  }\n\n  /**\n   * Remove an index.\n   * @param {string} fieldName Field name of the index to remove. Use the dot notation to remove an index referring to a\n   * field in a nested document.\n   * @return {Promise<void>}\n   * @see Datastore#removeIndex\n   */\n  async removeIndexAsync (fieldName) {\n    delete this.indexes[fieldName]\n\n    await this.executor.pushAsync(() => this.persistence.persistNewStateAsync([{ $$indexRemoved: fieldName }]), true)\n  }\n\n  /**\n   * Add one or several document(s) to all indexes.\n   *\n   * This is an internal function.\n   * @param {document} doc\n   * @private\n   */\n  _addToIndexes (doc) {\n    let failingIndex\n    let error\n    const keys = Object.keys(this.indexes)\n\n    for (let i = 0; i < keys.length; i += 1) {\n      try {\n        this.indexes[keys[i]].insert(doc)\n      } catch (e) {\n        failingIndex = i\n        error = e\n        break\n      }\n    }\n\n    // If an error happened, we need to rollback the insert on all other indexes\n    if (error) {\n      for (let i = 0; i < failingIndex; i += 1) {\n        this.indexes[keys[i]].remove(doc)\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Remove one or several document(s) from all indexes.\n   *\n   * This is an internal function.\n   * @param {document} doc\n   * @private\n   */\n  _removeFromIndexes (doc) {\n    for (const index of Object.values(this.indexes)) {\n      index.remove(doc)\n    }\n  }\n\n  /**\n   * Update one or several documents in all indexes.\n   *\n   * To update multiple documents, oldDoc must be an array of { oldDoc, newDoc } pairs.\n   *\n   * If one update violates a constraint, all changes are rolled back.\n   *\n   * This is an internal function.\n   * @param {document|Array.<{oldDoc: document, newDoc: document}>} oldDoc Document to update, or an `Array` of\n   * `{oldDoc, newDoc}` pairs.\n   * @param {document} [newDoc] Document to replace the oldDoc with. If the first argument is an `Array` of\n   * `{oldDoc, newDoc}` pairs, this second argument is ignored.\n   * @private\n   */\n  _updateIndexes (oldDoc, newDoc) {\n    let failingIndex\n    let error\n    const keys = Object.keys(this.indexes)\n\n    for (let i = 0; i < keys.length; i += 1) {\n      try {\n        this.indexes[keys[i]].update(oldDoc, newDoc)\n      } catch (e) {\n        failingIndex = i\n        error = e\n        break\n      }\n    }\n\n    // If an error happened, we need to rollback the update on all other indexes\n    if (error) {\n      for (let i = 0; i < failingIndex; i += 1) {\n        this.indexes[keys[i]].revertUpdate(oldDoc, newDoc)\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Get all candidate documents matching the query, regardless of their expiry status.\n   * @param {query} query\n   * @return {document[]}\n   *\n   * @private\n   */\n  _getRawCandidates (query) {\n    const indexNames = Object.keys(this.indexes)\n\n    // STEP 1: get candidates list by checking indexes from most to least frequent usecase\n    // For a basic match\n\n    let usableQuery\n    usableQuery = Object.entries(query)\n      .filter(filterIndexNames(indexNames))\n      .pop()\n    if (usableQuery) return this.indexes[usableQuery[0]].getMatching(usableQuery[1])\n\n    // For a compound match\n    const compoundQueryKeys = indexNames\n      .filter(indexName => indexName.indexOf(',') !== -1)\n      .map(indexName => indexName.split(','))\n      .filter(subIndexNames =>\n        Object.entries(query)\n          .filter(filterIndexNames(subIndexNames)).length === subIndexNames.length\n      )\n\n    if (compoundQueryKeys.length > 0) return this.indexes[compoundQueryKeys[0]].getMatching(pick(query, compoundQueryKeys[0]))\n\n    // For a $in match\n    usableQuery = Object.entries(query)\n      .filter(([k, v]) =>\n        !!(query[k] && Object.prototype.hasOwnProperty.call(query[k], '$in')) &&\n        indexNames.includes(k)\n      )\n      .pop()\n    if (usableQuery) return this.indexes[usableQuery[0]].getMatching(usableQuery[1].$in)\n    // For a comparison match\n    usableQuery = Object.entries(query)\n      .filter(([k, v]) =>\n        !!(query[k] && (Object.prototype.hasOwnProperty.call(query[k], '$lt') || Object.prototype.hasOwnProperty.call(query[k], '$lte') || Object.prototype.hasOwnProperty.call(query[k], '$gt') || Object.prototype.hasOwnProperty.call(query[k], '$gte'))) &&\n        indexNames.includes(k)\n      )\n      .pop()\n    if (usableQuery) return this.indexes[usableQuery[0]].getBetweenBounds(usableQuery[1])\n    // By default, return all the DB data\n    return this.getAllData()\n  }\n\n  /**\n   * Return the list of candidates for a given query\n   * Crude implementation for now, we return the candidates given by the first usable index if any\n   * We try the following query types, in this order: basic match, $in match, comparison match\n   * One way to make it better would be to enable the use of multiple indexes if the first usable index\n   * returns too much data. I may do it in the future.\n   *\n   * Returned candidates will be scanned to find and remove all expired documents\n   *\n   * This is an internal function.\n   * @param {query} query\n   * @param {boolean} [dontExpireStaleDocs = false] If true don't remove stale docs. Useful for the remove function\n   * which shouldn't be impacted by expirations.\n   * @return {Promise<document[]>} candidates\n   * @private\n   */\n  async _getCandidatesAsync (query, dontExpireStaleDocs = false) {\n    const validDocs = []\n\n    // STEP 1: get candidates list by checking indexes from most to least frequent usecase\n    const docs = this._getRawCandidates(query)\n    // STEP 2: remove all expired documents\n    if (!dontExpireStaleDocs) {\n      const expiredDocsIds = []\n      const ttlIndexesFieldNames = Object.keys(this.ttlIndexes)\n\n      docs.forEach(doc => {\n        if (ttlIndexesFieldNames.every(i => !(doc[i] !== undefined && isDate(doc[i]) && Date.now() > doc[i].getTime() + this.ttlIndexes[i] * 1000))) validDocs.push(doc)\n        else expiredDocsIds.push(doc._id)\n      })\n      for (const _id of expiredDocsIds) {\n        await this._removeAsync({ _id }, {})\n      }\n    } else validDocs.push(...docs)\n    return validDocs\n  }\n\n  /**\n   * Insert a new document\n   * This is an internal function, use {@link Datastore#insertAsync} which has the same signature.\n   * @param {document|document[]} newDoc\n   * @return {Promise<document|document[]>}\n   * @private\n   */\n  async _insertAsync (newDoc) {\n    const preparedDoc = this._prepareDocumentForInsertion(newDoc)\n    this._insertInCache(preparedDoc)\n\n    await this.persistence.persistNewStateAsync(Array.isArray(preparedDoc) ? preparedDoc : [preparedDoc])\n    return model.deepCopy(preparedDoc)\n  }\n\n  /**\n   * Create a new _id that's not already in use\n   * @return {string} id\n   * @private\n   */\n  _createNewId () {\n    let attemptId = customUtils.uid(16)\n    // Try as many times as needed to get an unused _id. As explained in customUtils, the probability of this ever happening is extremely small, so this is O(1)\n    if (this.indexes._id.getMatching(attemptId).length > 0) attemptId = this._createNewId()\n    return attemptId\n  }\n\n  /**\n   * Prepare a document (or array of documents) to be inserted in a database\n   * Meaning adds _id and timestamps if necessary on a copy of newDoc to avoid any side effect on user input\n   * @param {document|document[]} newDoc document, or Array of documents, to prepare\n   * @return {document|document[]} prepared document, or Array of prepared documents\n   * @private\n   */\n  _prepareDocumentForInsertion (newDoc) {\n    let preparedDoc\n\n    if (Array.isArray(newDoc)) {\n      preparedDoc = []\n      newDoc.forEach(doc => { preparedDoc.push(this._prepareDocumentForInsertion(doc)) })\n    } else {\n      preparedDoc = model.deepCopy(newDoc)\n      if (preparedDoc._id === undefined) preparedDoc._id = this._createNewId()\n      const now = new Date()\n      if (this.timestampData && preparedDoc.createdAt === undefined) preparedDoc.createdAt = now\n      if (this.timestampData && preparedDoc.updatedAt === undefined) preparedDoc.updatedAt = now\n      model.checkObject(preparedDoc)\n    }\n\n    return preparedDoc\n  }\n\n  /**\n   * If newDoc is an array of documents, this will insert all documents in the cache\n   * @param {document|document[]} preparedDoc\n   * @private\n   */\n  _insertInCache (preparedDoc) {\n    if (Array.isArray(preparedDoc)) this._insertMultipleDocsInCache(preparedDoc)\n    else this._addToIndexes(preparedDoc)\n  }\n\n  /**\n   * If one insertion fails (e.g. because of a unique constraint), roll back all previous\n   * inserts and throws the error\n   * @param {document[]} preparedDocs\n   * @private\n   */\n  _insertMultipleDocsInCache (preparedDocs) {\n    let failingIndex\n    let error\n\n    for (let i = 0; i < preparedDocs.length; i += 1) {\n      try {\n        this._addToIndexes(preparedDocs[i])\n      } catch (e) {\n        error = e\n        failingIndex = i\n        break\n      }\n    }\n\n    if (error) {\n      for (let i = 0; i < failingIndex; i += 1) {\n        this._removeFromIndexes(preparedDocs[i])\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Callback version of {@link Datastore#insertAsync}.\n   * @param {document|document[]} newDoc\n   * @param {SingleDocumentCallback|MultipleDocumentsCallback} [callback]\n   * @see Datastore#insertAsync\n   */\n  insert (newDoc, callback) {\n    const promise = this.insertAsync(newDoc)\n    if (typeof callback === 'function') callbackify(() => promise)(callback)\n  }\n\n  /**\n   * Insert a new document, or new documents.\n   * @param {document|document[]} newDoc Document or array of documents to insert.\n   * @return {Promise<document|document[]>} The document(s) inserted.\n   * @async\n   */\n  insertAsync (newDoc) {\n    return this.executor.pushAsync(() => this._insertAsync(newDoc))\n  }\n\n  /**\n   * Callback for {@link Datastore#countCallback}.\n   * @callback Datastore~countCallback\n   * @param {?Error} err\n   * @param {?number} count\n   */\n\n  /**\n   * Callback-version of {@link Datastore#countAsync}.\n   * @param {query} query\n   * @param {Datastore~countCallback} [callback]\n   * @return {Cursor<number>|undefined}\n   * @see Datastore#countAsync\n   */\n  count (query, callback) {\n    const cursor = this.countAsync(query)\n\n    if (typeof callback === 'function') callbackify(cursor.execAsync.bind(cursor))(callback)\n    else return cursor\n  }\n\n  /**\n   * Count all documents matching the query.\n   * @param {query} query MongoDB-style query\n   * @return {Cursor<number>} count\n   * @async\n   */\n  countAsync (query) {\n    return new Cursor(this, query, docs => docs.length)\n  }\n\n  /**\n   * Callback version of {@link Datastore#findAsync}.\n   * @param {query} query\n   * @param {projection|MultipleDocumentsCallback} [projection = {}]\n   * @param {MultipleDocumentsCallback} [callback]\n   * @return {Cursor<document[]>|undefined}\n   * @see Datastore#findAsync\n   */\n  find (query, projection, callback) {\n    if (arguments.length === 1) {\n      projection = {}\n      // callback is undefined, will return a cursor\n    } else if (arguments.length === 2) {\n      if (typeof projection === 'function') {\n        callback = projection\n        projection = {}\n      } // If not assume projection is an object and callback undefined\n    }\n\n    const cursor = this.findAsync(query, projection)\n\n    if (typeof callback === 'function') callbackify(cursor.execAsync.bind(cursor))(callback)\n    else return cursor\n  }\n\n  /**\n   * Find all documents matching the query.\n   * We return the {@link Cursor} that the user can either `await` directly or use to can {@link Cursor#limit} or\n   * {@link Cursor#skip} before.\n   * @param {query} query MongoDB-style query\n   * @param {projection} [projection = {}] MongoDB-style projection\n   * @return {Cursor<document[]>}\n   * @async\n   */\n  findAsync (query, projection = {}) {\n    const cursor = new Cursor(this, query, docs => docs.map(doc => model.deepCopy(doc)))\n\n    cursor.projection(projection)\n    return cursor\n  }\n\n  /**\n   * @callback Datastore~findOneCallback\n   * @param {?Error} err\n   * @param {document} doc\n   */\n\n  /**\n   * Callback version of {@link Datastore#findOneAsync}.\n   * @param {query} query\n   * @param {projection|SingleDocumentCallback} [projection = {}]\n   * @param {SingleDocumentCallback} [callback]\n   * @return {Cursor<document>|undefined}\n   * @see Datastore#findOneAsync\n   */\n  findOne (query, projection, callback) {\n    if (arguments.length === 1) {\n      projection = {}\n      // callback is undefined, will return a cursor\n    } else if (arguments.length === 2) {\n      if (typeof projection === 'function') {\n        callback = projection\n        projection = {}\n      } // If not assume projection is an object and callback undefined\n    }\n\n    const cursor = this.findOneAsync(query, projection)\n\n    if (typeof callback === 'function') callbackify(cursor.execAsync.bind(cursor))(callback)\n    else return cursor\n  }\n\n  /**\n   * Find one document matching the query.\n   * We return the {@link Cursor} that the user can either `await` directly or use to can {@link Cursor#skip} before.\n   * @param {query} query MongoDB-style query\n   * @param {projection} projection MongoDB-style projection\n   * @return {Cursor<document>}\n   */\n  findOneAsync (query, projection = {}) {\n    const cursor = new Cursor(this, query, docs => docs.length === 1 ? model.deepCopy(docs[0]) : null)\n\n    cursor.projection(projection).limit(1)\n    return cursor\n  }\n\n  /**\n   * See {@link Datastore#updateAsync} return type for the definition of the callback parameters.\n   *\n   * **WARNING:** Prior to 3.0.0, `upsert` was either `true` of falsy (but not `false`), it is now always a boolean.\n   * `affectedDocuments` could be `undefined` when `returnUpdatedDocs` was `false`, it is now `null` in these cases.\n   *\n   * **WARNING:** Prior to 1.8.0, the `upsert` argument was not given, it was impossible for the developer to determine\n   * during a `{ multi: false, returnUpdatedDocs: true, upsert: true }` update if it inserted a document or just updated\n   * it.\n   *\n   * @callback Datastore~updateCallback\n   * @param {?Error} err\n   * @param {number} numAffected\n   * @param {?document[]|?document} affectedDocuments\n   * @param {boolean} upsert\n   * @see {Datastore#updateAsync}\n   */\n\n  /**\n   * Version without the using {@link Datastore~executor} of {@link Datastore#updateAsync}, use it instead.\n   *\n   * @param {query} query\n   * @param {document|update} update\n   * @param {Object} options\n   * @param {boolean} [options.multi = false]\n   * @param {boolean} [options.upsert = false]\n   * @param {boolean} [options.returnUpdatedDocs = false]\n   * @return {Promise<{numAffected: number, affectedDocuments: document[]|document|null, upsert: boolean}>}\n   * @private\n   * @see Datastore#updateAsync\n   */\n  async _updateAsync (query, update, options) {\n    const multi = options.multi !== undefined ? options.multi : false\n    const upsert = options.upsert !== undefined ? options.upsert : false\n\n    // If upsert option is set, check whether we need to insert the doc\n    if (upsert) {\n      const cursor = new Cursor(this, query)\n\n      // Need to use an internal function not tied to the executor to avoid deadlock\n      const docs = await cursor.limit(1)._execAsync()\n\n      if (docs.length !== 1) {\n        let toBeInserted\n\n        try {\n          model.checkObject(update)\n          // updateQuery is a simple object with no modifier, use it as the document to insert\n          toBeInserted = update\n        } catch (e) {\n          // updateQuery contains modifiers, use the find query as the base,\n          // strip it from all operators and update it according to updateQuery\n          toBeInserted = model.modify(model.deepCopy(query, true), update)\n        }\n        const newDoc = await this._insertAsync(toBeInserted)\n        return { numAffected: 1, affectedDocuments: newDoc, upsert: true }\n      }\n    }\n    // Perform the update\n    let numReplaced = 0\n    let modifiedDoc\n    const modifications = []\n    let createdAt\n\n    const candidates = await this._getCandidatesAsync(query)\n    // Preparing update (if an error is thrown here neither the datafile nor\n    // the in-memory indexes are affected)\n    for (const candidate of candidates) {\n      if (model.match(candidate, query) && (multi || numReplaced === 0)) {\n        numReplaced += 1\n        if (this.timestampData) { createdAt = candidate.createdAt }\n        modifiedDoc = model.modify(candidate, update)\n        if (this.timestampData) {\n          modifiedDoc.createdAt = createdAt\n          modifiedDoc.updatedAt = new Date()\n        }\n        modifications.push({ oldDoc: candidate, newDoc: modifiedDoc })\n      }\n    }\n\n    // Change the docs in memory\n    this._updateIndexes(modifications)\n\n    // Update the datafile\n    const updatedDocs = modifications.map(x => x.newDoc)\n    await this.persistence.persistNewStateAsync(updatedDocs)\n    if (!options.returnUpdatedDocs) return { numAffected: numReplaced, upsert: false, affectedDocuments: null }\n    else {\n      let updatedDocsDC = []\n      updatedDocs.forEach(doc => { updatedDocsDC.push(model.deepCopy(doc)) })\n      if (!multi) updatedDocsDC = updatedDocsDC[0]\n      return { numAffected: numReplaced, affectedDocuments: updatedDocsDC, upsert: false }\n    }\n  }\n\n  /**\n   * Callback version of {@link Datastore#updateAsync}.\n   * @param {query} query\n   * @param {document|*} update\n   * @param {Object|Datastore~updateCallback} [options|]\n   * @param {boolean} [options.multi = false]\n   * @param {boolean} [options.upsert = false]\n   * @param {boolean} [options.returnUpdatedDocs = false]\n   * @param {Datastore~updateCallback} [callback]\n   * @see Datastore#updateAsync\n   *\n   */\n  update (query, update, options, callback) {\n    if (typeof options === 'function') {\n      callback = options\n      options = {}\n    }\n    const _callback = (err, res = {}) => {\n      if (callback) callback(err, res.numAffected, res.affectedDocuments, res.upsert)\n    }\n    callbackify((query, update, options) => this.updateAsync(query, update, options))(query, update, options, _callback)\n  }\n\n  /**\n   * Update all docs matching query.\n   * @param {query} query is the same kind of finding query you use with `find` and `findOne`.\n   * @param {document|*} update specifies how the documents should be modified. It is either a new document or a\n   * set of modifiers (you cannot use both together, it doesn't make sense!). Using a new document will replace the\n   * matched docs. Using a set of modifiers will create the fields they need to modify if they don't exist, and you can\n   * apply them to subdocs. Available field modifiers are `$set` to change a field's value, `$unset` to delete a field,\n   * `$inc` to increment a field's value and `$min`/`$max` to change field's value, only if provided value is\n   * less/greater than current value. To work on arrays, you have `$push`, `$pop`, `$addToSet`, `$pull`, and the special\n   * `$each` and `$slice`.\n   * @param {Object} [options = {}] Optional options\n   * @param {boolean} [options.multi = false] If true, can update multiple documents\n   * @param {boolean} [options.upsert = false] If true, can insert a new document corresponding to the `update` rules if\n   * your `query` doesn't match anything. If your `update` is a simple object with no modifiers, it is the inserted\n   * document. In the other case, the `query` is stripped from all operator recursively, and the `update` is applied to\n   * it.\n   * @param {boolean} [options.returnUpdatedDocs = false] (not Mongo-DB compatible) If true and update is not an upsert,\n   * will return the array of documents matched by the find query and updated. Updated documents will be returned even\n   * if the update did not actually modify them.\n   * @return {Promise<{numAffected: number, affectedDocuments: document[]|document|null, upsert: boolean}>}\n   * - `upsert` is `true` if and only if the update did insert a document, **cannot be true if `options.upsert !== true`**.\n   * - `numAffected` is the number of documents affected by the update or insertion (if `options.multi` is `false` or `options.upsert` is `true`, cannot exceed `1`);\n   * - `affectedDocuments` can be one of the following:\n   *    - If `upsert` is `true`, the inserted document;\n   *    - If `options.returnUpdatedDocs` is `false`, `null`;\n   *    - If `options.returnUpdatedDocs` is `true`:\n   *      - If `options.multi` is `false`, the updated document;\n   *      - If `options.multi` is `true`, the array of updated documents.\n   * @async\n   */\n  updateAsync (query, update, options = {}) {\n    return this.executor.pushAsync(() => this._updateAsync(query, update, options))\n  }\n\n  /**\n   * @callback Datastore~removeCallback\n   * @param {?Error} err\n   * @param {?number} numRemoved\n   */\n\n  /**\n   * Internal version without using the {@link Datastore#executor} of {@link Datastore#removeAsync}, use it instead.\n   *\n   * @param {query} query\n   * @param {object} [options]\n   * @param {boolean} [options.multi = false]\n   * @return {Promise<number>}\n   * @private\n   * @see Datastore#removeAsync\n   */\n  async _removeAsync (query, options = {}) {\n    const multi = options.multi !== undefined ? options.multi : false\n\n    const candidates = await this._getCandidatesAsync(query, true)\n    const removedDocs = []\n    let numRemoved = 0\n\n    candidates.forEach(d => {\n      if (model.match(d, query) && (multi || numRemoved === 0)) {\n        numRemoved += 1\n        removedDocs.push({ $$deleted: true, _id: d._id })\n        this._removeFromIndexes(d)\n      }\n    })\n\n    await this.persistence.persistNewStateAsync(removedDocs)\n    return numRemoved\n  }\n\n  /**\n   * Callback version of {@link Datastore#removeAsync}.\n   * @param {query} query\n   * @param {object|Datastore~removeCallback} [options={}]\n   * @param {boolean} [options.multi = false]\n   * @param {Datastore~removeCallback} [cb = () => {}]\n   * @see Datastore#removeAsync\n   */\n  remove (query, options, cb) {\n    if (typeof options === 'function') {\n      cb = options\n      options = {}\n    }\n    const callback = cb || (() => {})\n    callbackify((query, options) => this.removeAsync(query, options))(query, options, callback)\n  }\n\n  /**\n   * Remove all docs matching the query.\n   * @param {query} query MongoDB-style query\n   * @param {object} [options={}] Optional options\n   * @param {boolean} [options.multi = false] If true, can update multiple documents\n   * @return {Promise<number>} How many documents were removed\n   * @async\n   */\n  removeAsync (query, options = {}) {\n    return this.executor.pushAsync(() => this._removeAsync(query, options))\n  }\n}\n\nmodule.exports = Datastore\n"],"mappings":"AAAA,MAAM;EAAEA;AAAa,CAAC,GAAGC,OAAO,CAAC,QAAQ,CAAC;AAC1C,MAAM;EAAEC,WAAW;EAAEC;AAAU,CAAC,GAAGF,OAAO,CAAC,MAAM,CAAC;AAClD,MAAMG,MAAM,GAAGH,OAAO,CAAC,aAAa,CAAC;AACrC,MAAMI,WAAW,GAAGJ,OAAO,CAAC,kBAAkB,CAAC;AAC/C,MAAMK,QAAQ,GAAGL,OAAO,CAAC,eAAe,CAAC;AACzC,MAAMM,KAAK,GAAGN,OAAO,CAAC,cAAc,CAAC;AACrC,MAAMO,KAAK,GAAGP,OAAO,CAAC,YAAY,CAAC;AACnC,MAAMQ,WAAW,GAAGR,OAAO,CAAC,kBAAkB,CAAC;AAC/C,MAAM;EAAES,MAAM;EAAEC,IAAI;EAAEC;AAAiB,CAAC,GAAGX,OAAO,CAAC,YAAY,CAAC;;AAEhE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMY,SAAS,SAASb,YAAY,CAAC;EACnC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}