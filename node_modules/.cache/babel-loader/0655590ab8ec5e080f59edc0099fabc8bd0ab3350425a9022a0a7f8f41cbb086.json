{"ast":null,"code":"const BinarySearchTree = require('@seald-io/binary-search-tree').AVLTree;\nconst model = require('./model.js');\nconst {\n  uniq,\n  isDate\n} = require('./utils.js');\n\n/**\n * Two indexed pointers are equal if they point to the same place\n * @param {*} a\n * @param {*} b\n * @return {boolean}\n * @private\n */\nconst checkValueEquality = (a, b) => a === b;\n\n/**\n * Type-aware projection\n * @param {*} elt\n * @return {string|*}\n * @private\n */\nconst projectForUnique = elt => {\n  if (elt === null) return '$null';\n  if (typeof elt === 'string') return '$string' + elt;\n  if (typeof elt === 'boolean') return '$boolean' + elt;\n  if (typeof elt === 'number') return '$number' + elt;\n  if (isDate(elt)) return '$date' + elt.getTime();\n  return elt; // Arrays and objects, will check for pointer equality\n};\n\n/**\n * Indexes on field names, with atomic operations and which can optionally enforce a unique constraint or allow indexed\n * fields to be undefined\n * @private\n */\nclass Index {\n  /**\n   * Create a new index\n   * All methods on an index guarantee that either the whole operation was successful and the index changed\n   * or the operation was unsuccessful and an error is thrown while the index is unchanged\n   * @param {object} options\n   * @param {string} options.fieldName On which field should the index apply, can use dot notation to index on sub fields, can use comma-separated notation to use compound indexes\n   * @param {boolean} [options.unique = false] Enforces a unique constraint\n   * @param {boolean} [options.sparse = false] Allows a sparse index (we can have documents for which fieldName is `undefined`)\n   */\n  constructor(options) {\n    /**\n     * On which field the index applies to, can use dot notation to index on sub fields, can use comma-separated notation to use compound indexes.\n     * @type {string}\n     */\n    this.fieldName = options.fieldName;\n    if (typeof this.fieldName !== 'string') throw new Error('fieldName must be a string');\n\n    /**\n     * Internal property which is an Array representing the fieldName split with `,`, useful only for compound indexes.\n     * @type {string[]}\n     * @private\n     */\n    this._fields = this.fieldName.split(',');\n\n    /**\n     * Defines if the index enforces a unique constraint for this index.\n     * @type {boolean}\n     */\n    this.unique = options.unique || false;\n    /**\n     * Defines if we can have documents for which fieldName is `undefined`\n     * @type {boolean}\n     */\n    this.sparse = options.sparse || false;\n\n    /**\n     * Options object given to the underlying BinarySearchTree.\n     * @type {{unique: boolean, checkValueEquality: (function(*, *): boolean), compareKeys: ((function(*, *, compareStrings): (number|number))|*)}}\n     */\n    this.treeOptions = {\n      unique: this.unique,\n      compareKeys: model.compareThings,\n      checkValueEquality\n    };\n\n    /**\n     * Underlying BinarySearchTree for this index. Uses an AVLTree for optimization.\n     * @type {AVLTree}\n     */\n    this.tree = new BinarySearchTree(this.treeOptions);\n  }\n\n  /**\n   * Reset an index\n   * @param {?document|?document[]} [newData] Data to initialize the index with. If an error is thrown during\n   * insertion, the index is not modified.\n   */\n  reset(newData) {\n    this.tree = new BinarySearchTree(this.treeOptions);\n    if (newData) this.insert(newData);\n  }\n\n  /**\n   * Insert a new document in the index\n   * If an array is passed, we insert all its elements (if one insertion fails the index is not modified)\n   * O(log(n))\n   * @param {document|document[]} doc The document, or array of documents, to insert.\n   */\n  insert(doc) {\n    let keys;\n    let failingIndex;\n    let error;\n    if (Array.isArray(doc)) {\n      this.insertMultipleDocs(doc);\n      return;\n    }\n    const key = model.getDotValues(doc, this._fields);\n\n    // We don't index documents that don't contain the field if the index is sparse\n    if ((key === undefined || typeof key === 'object' && key !== null && Object.values(key).every(el => el === undefined)) && this.sparse) return;\n    if (!Array.isArray(key)) this.tree.insert(key, doc);else {\n      // If an insert fails due to a unique constraint, roll back all inserts before it\n      keys = uniq(key, projectForUnique);\n      for (let i = 0; i < keys.length; i += 1) {\n        try {\n          this.tree.insert(keys[i], doc);\n        } catch (e) {\n          error = e;\n          failingIndex = i;\n          break;\n        }\n      }\n      if (error) {\n        for (let i = 0; i < failingIndex; i += 1) {\n          this.tree.delete(keys[i], doc);\n        }\n        throw error;\n      }\n    }\n  }\n\n  /**\n   * Insert an array of documents in the index\n   * If a constraint is violated, the changes should be rolled back and an error thrown\n   * @param {document[]} docs Array of documents to insert.\n   * @private\n   */\n  insertMultipleDocs(docs) {\n    let error;\n    let failingIndex;\n    for (let i = 0; i < docs.length; i += 1) {\n      try {\n        this.insert(docs[i]);\n      } catch (e) {\n        error = e;\n        failingIndex = i;\n        break;\n      }\n    }\n    if (error) {\n      for (let i = 0; i < failingIndex; i += 1) {\n        this.remove(docs[i]);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Removes a document from the index.\n   * If an array is passed, we remove all its elements\n   * The remove operation is safe with regards to the 'unique' constraint\n   * O(log(n))\n   * @param {document[]|document} doc The document, or Array of documents, to remove.\n   */\n  remove(doc) {\n    if (Array.isArray(doc)) {\n      doc.forEach(d => {\n        this.remove(d);\n      });\n      return;\n    }\n    const key = model.getDotValues(doc, this._fields);\n    if (key === undefined && this.sparse) return;\n    if (!Array.isArray(key)) {\n      this.tree.delete(key, doc);\n    } else {\n      uniq(key, projectForUnique).forEach(_key => {\n        this.tree.delete(_key, doc);\n      });\n    }\n  }\n\n  /**\n   * Update a document in the index\n   * If a constraint is violated, changes are rolled back and an error thrown\n   * Naive implementation, still in O(log(n))\n   * @param {document|Array.<{oldDoc: document, newDoc: document}>} oldDoc Document to update, or an `Array` of\n   * `{oldDoc, newDoc}` pairs.\n   * @param {document} [newDoc] Document to replace the oldDoc with. If the first argument is an `Array` of\n   * `{oldDoc, newDoc}` pairs, this second argument is ignored.\n   */\n  update(oldDoc, newDoc) {\n    if (Array.isArray(oldDoc)) {\n      this.updateMultipleDocs(oldDoc);\n      return;\n    }\n    this.remove(oldDoc);\n    try {\n      this.insert(newDoc);\n    } catch (e) {\n      this.insert(oldDoc);\n      throw e;\n    }\n  }\n\n  /**\n   * Update multiple documents in the index\n   * If a constraint is violated, the changes need to be rolled back\n   * and an error thrown\n   * @param {Array.<{oldDoc: document, newDoc: document}>} pairs\n   *\n   * @private\n   */\n  updateMultipleDocs(pairs) {\n    let failingIndex;\n    let error;\n    for (let i = 0; i < pairs.length; i += 1) {\n      this.remove(pairs[i].oldDoc);\n    }\n    for (let i = 0; i < pairs.length; i += 1) {\n      try {\n        this.insert(pairs[i].newDoc);\n      } catch (e) {\n        error = e;\n        failingIndex = i;\n        break;\n      }\n    }\n\n    // If an error was raised, roll back changes in the inverse order\n    if (error) {\n      for (let i = 0; i < failingIndex; i += 1) {\n        this.remove(pairs[i].newDoc);\n      }\n      for (let i = 0; i < pairs.length; i += 1) {\n        this.insert(pairs[i].oldDoc);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Revert an update\n   * @param {document|Array.<{oldDoc: document, newDoc: document}>} oldDoc Document to revert to, or an `Array` of `{oldDoc, newDoc}` pairs.\n   * @param {document} [newDoc] Document to revert from. If the first argument is an Array of {oldDoc, newDoc}, this second argument is ignored.\n   */\n  revertUpdate(oldDoc, newDoc) {\n    const revert = [];\n    if (!Array.isArray(oldDoc)) this.update(newDoc, oldDoc);else {\n      oldDoc.forEach(pair => {\n        revert.push({\n          oldDoc: pair.newDoc,\n          newDoc: pair.oldDoc\n        });\n      });\n      this.update(revert);\n    }\n  }\n\n  /**\n   * Get all documents in index whose key match value (if it is a Thing) or one of the elements of value (if it is an array of Things)\n   * @param {Array.<*>|*} value Value to match the key against\n   * @return {document[]}\n   */\n  getMatching(value) {\n    if (!Array.isArray(value)) return this.tree.search(value);else {\n      const _res = {};\n      const res = [];\n      value.forEach(v => {\n        this.getMatching(v).forEach(doc => {\n          _res[doc._id] = doc;\n        });\n      });\n      Object.keys(_res).forEach(_id => {\n        res.push(_res[_id]);\n      });\n      return res;\n    }\n  }\n\n  /**\n   * Get all documents in index whose key is between bounds are they are defined by query\n   * Documents are sorted by key\n   * @param {object} query An object with at least one matcher among $gt, $gte, $lt, $lte.\n   * @param {*} [query.$gt] Greater than matcher.\n   * @param {*} [query.$gte] Greater than or equal matcher.\n   * @param {*} [query.$lt] Lower than matcher.\n   * @param {*} [query.$lte] Lower than or equal matcher.\n   * @return {document[]}\n   */\n  getBetweenBounds(query) {\n    return this.tree.betweenBounds(query);\n  }\n\n  /**\n   * Get all elements in the index\n   * @return {document[]}\n   */\n  getAll() {\n    const res = [];\n    this.tree.executeOnEveryNode(node => {\n      res.push(...node.data);\n    });\n    return res;\n  }\n}\n\n// Interface\nmodule.exports = Index;","map":{"version":3,"names":["BinarySearchTree","require","AVLTree","model","uniq","isDate","checkValueEquality","a","b","projectForUnique","elt","getTime","Index","constructor","options","fieldName","Error","_fields","split","unique","sparse","treeOptions","compareKeys","compareThings","tree","reset","newData","insert","doc","keys","failingIndex","error","Array","isArray","insertMultipleDocs","key","getDotValues","undefined","Object","values","every","el","i","length","e","delete","docs","remove","forEach","d","_key","update","oldDoc","newDoc","updateMultipleDocs","pairs","revertUpdate","revert","pair","push","getMatching","value","search","_res","res","v","_id","getBetweenBounds","query","betweenBounds","getAll","executeOnEveryNode","node","data","module","exports"],"sources":["C:/Users/benit/Music/arbisout/node_modules/@seald-io/nedb/lib/indexes.js"],"sourcesContent":["const BinarySearchTree = require('@seald-io/binary-search-tree').AVLTree\nconst model = require('./model.js')\nconst { uniq, isDate } = require('./utils.js')\n\n/**\n * Two indexed pointers are equal if they point to the same place\n * @param {*} a\n * @param {*} b\n * @return {boolean}\n * @private\n */\nconst checkValueEquality = (a, b) => a === b\n\n/**\n * Type-aware projection\n * @param {*} elt\n * @return {string|*}\n * @private\n */\nconst projectForUnique = elt => {\n  if (elt === null) return '$null'\n  if (typeof elt === 'string') return '$string' + elt\n  if (typeof elt === 'boolean') return '$boolean' + elt\n  if (typeof elt === 'number') return '$number' + elt\n  if (isDate(elt)) return '$date' + elt.getTime()\n\n  return elt // Arrays and objects, will check for pointer equality\n}\n\n/**\n * Indexes on field names, with atomic operations and which can optionally enforce a unique constraint or allow indexed\n * fields to be undefined\n * @private\n */\nclass Index {\n  /**\n   * Create a new index\n   * All methods on an index guarantee that either the whole operation was successful and the index changed\n   * or the operation was unsuccessful and an error is thrown while the index is unchanged\n   * @param {object} options\n   * @param {string} options.fieldName On which field should the index apply, can use dot notation to index on sub fields, can use comma-separated notation to use compound indexes\n   * @param {boolean} [options.unique = false] Enforces a unique constraint\n   * @param {boolean} [options.sparse = false] Allows a sparse index (we can have documents for which fieldName is `undefined`)\n   */\n  constructor (options) {\n    /**\n     * On which field the index applies to, can use dot notation to index on sub fields, can use comma-separated notation to use compound indexes.\n     * @type {string}\n     */\n    this.fieldName = options.fieldName\n\n    if (typeof this.fieldName !== 'string') throw new Error('fieldName must be a string')\n\n    /**\n     * Internal property which is an Array representing the fieldName split with `,`, useful only for compound indexes.\n     * @type {string[]}\n     * @private\n     */\n    this._fields = this.fieldName.split(',')\n\n    /**\n     * Defines if the index enforces a unique constraint for this index.\n     * @type {boolean}\n     */\n    this.unique = options.unique || false\n    /**\n     * Defines if we can have documents for which fieldName is `undefined`\n     * @type {boolean}\n     */\n    this.sparse = options.sparse || false\n\n    /**\n     * Options object given to the underlying BinarySearchTree.\n     * @type {{unique: boolean, checkValueEquality: (function(*, *): boolean), compareKeys: ((function(*, *, compareStrings): (number|number))|*)}}\n     */\n    this.treeOptions = { unique: this.unique, compareKeys: model.compareThings, checkValueEquality }\n\n    /**\n     * Underlying BinarySearchTree for this index. Uses an AVLTree for optimization.\n     * @type {AVLTree}\n     */\n    this.tree = new BinarySearchTree(this.treeOptions)\n  }\n\n  /**\n   * Reset an index\n   * @param {?document|?document[]} [newData] Data to initialize the index with. If an error is thrown during\n   * insertion, the index is not modified.\n   */\n  reset (newData) {\n    this.tree = new BinarySearchTree(this.treeOptions)\n\n    if (newData) this.insert(newData)\n  }\n\n  /**\n   * Insert a new document in the index\n   * If an array is passed, we insert all its elements (if one insertion fails the index is not modified)\n   * O(log(n))\n   * @param {document|document[]} doc The document, or array of documents, to insert.\n   */\n  insert (doc) {\n    let keys\n    let failingIndex\n    let error\n\n    if (Array.isArray(doc)) {\n      this.insertMultipleDocs(doc)\n      return\n    }\n\n    const key = model.getDotValues(doc, this._fields)\n\n    // We don't index documents that don't contain the field if the index is sparse\n    if ((key === undefined || (typeof key === 'object' && key !== null && Object.values(key).every(el => el === undefined))) && this.sparse) return\n\n    if (!Array.isArray(key)) this.tree.insert(key, doc)\n    else {\n      // If an insert fails due to a unique constraint, roll back all inserts before it\n      keys = uniq(key, projectForUnique)\n\n      for (let i = 0; i < keys.length; i += 1) {\n        try {\n          this.tree.insert(keys[i], doc)\n        } catch (e) {\n          error = e\n          failingIndex = i\n          break\n        }\n      }\n\n      if (error) {\n        for (let i = 0; i < failingIndex; i += 1) {\n          this.tree.delete(keys[i], doc)\n        }\n\n        throw error\n      }\n    }\n  }\n\n  /**\n   * Insert an array of documents in the index\n   * If a constraint is violated, the changes should be rolled back and an error thrown\n   * @param {document[]} docs Array of documents to insert.\n   * @private\n   */\n  insertMultipleDocs (docs) {\n    let error\n    let failingIndex\n\n    for (let i = 0; i < docs.length; i += 1) {\n      try {\n        this.insert(docs[i])\n      } catch (e) {\n        error = e\n        failingIndex = i\n        break\n      }\n    }\n\n    if (error) {\n      for (let i = 0; i < failingIndex; i += 1) {\n        this.remove(docs[i])\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Removes a document from the index.\n   * If an array is passed, we remove all its elements\n   * The remove operation is safe with regards to the 'unique' constraint\n   * O(log(n))\n   * @param {document[]|document} doc The document, or Array of documents, to remove.\n   */\n  remove (doc) {\n    if (Array.isArray(doc)) {\n      doc.forEach(d => { this.remove(d) })\n      return\n    }\n\n    const key = model.getDotValues(doc, this._fields)\n    if (key === undefined && this.sparse) return\n\n    if (!Array.isArray(key)) {\n      this.tree.delete(key, doc)\n    } else {\n      uniq(key, projectForUnique).forEach(_key => {\n        this.tree.delete(_key, doc)\n      })\n    }\n  }\n\n  /**\n   * Update a document in the index\n   * If a constraint is violated, changes are rolled back and an error thrown\n   * Naive implementation, still in O(log(n))\n   * @param {document|Array.<{oldDoc: document, newDoc: document}>} oldDoc Document to update, or an `Array` of\n   * `{oldDoc, newDoc}` pairs.\n   * @param {document} [newDoc] Document to replace the oldDoc with. If the first argument is an `Array` of\n   * `{oldDoc, newDoc}` pairs, this second argument is ignored.\n   */\n  update (oldDoc, newDoc) {\n    if (Array.isArray(oldDoc)) {\n      this.updateMultipleDocs(oldDoc)\n      return\n    }\n\n    this.remove(oldDoc)\n\n    try {\n      this.insert(newDoc)\n    } catch (e) {\n      this.insert(oldDoc)\n      throw e\n    }\n  }\n\n  /**\n   * Update multiple documents in the index\n   * If a constraint is violated, the changes need to be rolled back\n   * and an error thrown\n   * @param {Array.<{oldDoc: document, newDoc: document}>} pairs\n   *\n   * @private\n   */\n  updateMultipleDocs (pairs) {\n    let failingIndex\n    let error\n\n    for (let i = 0; i < pairs.length; i += 1) {\n      this.remove(pairs[i].oldDoc)\n    }\n\n    for (let i = 0; i < pairs.length; i += 1) {\n      try {\n        this.insert(pairs[i].newDoc)\n      } catch (e) {\n        error = e\n        failingIndex = i\n        break\n      }\n    }\n\n    // If an error was raised, roll back changes in the inverse order\n    if (error) {\n      for (let i = 0; i < failingIndex; i += 1) {\n        this.remove(pairs[i].newDoc)\n      }\n\n      for (let i = 0; i < pairs.length; i += 1) {\n        this.insert(pairs[i].oldDoc)\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Revert an update\n   * @param {document|Array.<{oldDoc: document, newDoc: document}>} oldDoc Document to revert to, or an `Array` of `{oldDoc, newDoc}` pairs.\n   * @param {document} [newDoc] Document to revert from. If the first argument is an Array of {oldDoc, newDoc}, this second argument is ignored.\n   */\n  revertUpdate (oldDoc, newDoc) {\n    const revert = []\n\n    if (!Array.isArray(oldDoc)) this.update(newDoc, oldDoc)\n    else {\n      oldDoc.forEach(pair => {\n        revert.push({ oldDoc: pair.newDoc, newDoc: pair.oldDoc })\n      })\n      this.update(revert)\n    }\n  }\n\n  /**\n   * Get all documents in index whose key match value (if it is a Thing) or one of the elements of value (if it is an array of Things)\n   * @param {Array.<*>|*} value Value to match the key against\n   * @return {document[]}\n   */\n  getMatching (value) {\n    if (!Array.isArray(value)) return this.tree.search(value)\n    else {\n      const _res = {}\n      const res = []\n\n      value.forEach(v => {\n        this.getMatching(v).forEach(doc => {\n          _res[doc._id] = doc\n        })\n      })\n\n      Object.keys(_res).forEach(_id => {\n        res.push(_res[_id])\n      })\n\n      return res\n    }\n  }\n\n  /**\n   * Get all documents in index whose key is between bounds are they are defined by query\n   * Documents are sorted by key\n   * @param {object} query An object with at least one matcher among $gt, $gte, $lt, $lte.\n   * @param {*} [query.$gt] Greater than matcher.\n   * @param {*} [query.$gte] Greater than or equal matcher.\n   * @param {*} [query.$lt] Lower than matcher.\n   * @param {*} [query.$lte] Lower than or equal matcher.\n   * @return {document[]}\n   */\n  getBetweenBounds (query) {\n    return this.tree.betweenBounds(query)\n  }\n\n  /**\n   * Get all elements in the index\n   * @return {document[]}\n   */\n  getAll () {\n    const res = []\n\n    this.tree.executeOnEveryNode(node => {\n      res.push(...node.data)\n    })\n\n    return res\n  }\n}\n\n// Interface\nmodule.exports = Index\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}