{"ast":null,"code":"/**\n * Simple binary search tree\n */\nconst customUtils = require('./customUtils');\nclass BinarySearchTree {\n  /**\n   * Constructor\n   * @param {Object} options Optional\n   * @param {Boolean}  options.unique Whether to enforce a 'unique' constraint on the key or not\n   * @param {Key}      options.key Initialize this BST's key with key\n   * @param {Value}    options.value Initialize this BST's data with [value]\n   * @param {Function} options.compareKeys Initialize this BST's compareKeys\n   */\n  constructor(options) {\n    options = options || {};\n    this.left = null;\n    this.right = null;\n    this.parent = options.parent !== undefined ? options.parent : null;\n    if (Object.prototype.hasOwnProperty.call(options, 'key')) {\n      this.key = options.key;\n    }\n    this.data = Object.prototype.hasOwnProperty.call(options, 'value') ? [options.value] : [];\n    this.unique = options.unique || false;\n    this.compareKeys = options.compareKeys || customUtils.defaultCompareKeysFunction;\n    this.checkValueEquality = options.checkValueEquality || customUtils.defaultCheckValueEquality;\n  }\n\n  /**\n   * Get the descendant with max key\n   */\n  getMaxKeyDescendant() {\n    if (this.right) return this.right.getMaxKeyDescendant();else return this;\n  }\n\n  /**\n   * Get the maximum key\n   */\n  getMaxKey() {\n    return this.getMaxKeyDescendant().key;\n  }\n\n  /**\n   * Get the descendant with min key\n   */\n  getMinKeyDescendant() {\n    if (this.left) return this.left.getMinKeyDescendant();else return this;\n  }\n\n  /**\n   * Get the minimum key\n   */\n  getMinKey() {\n    return this.getMinKeyDescendant().key;\n  }\n\n  /**\n   * Check that all nodes (incl. leaves) fullfil condition given by fn\n   * test is a function passed every (key, data) and which throws if the condition is not met\n   */\n  checkAllNodesFullfillCondition(test) {\n    if (!Object.prototype.hasOwnProperty.call(this, 'key')) return;\n    test(this.key, this.data);\n    if (this.left) this.left.checkAllNodesFullfillCondition(test);\n    if (this.right) this.right.checkAllNodesFullfillCondition(test);\n  }\n\n  /**\n   * Check that the core BST properties on node ordering are verified\n   * Throw if they aren't\n   */\n  checkNodeOrdering() {\n    if (!Object.prototype.hasOwnProperty.call(this, 'key')) return;\n    if (this.left) {\n      this.left.checkAllNodesFullfillCondition(k => {\n        if (this.compareKeys(k, this.key) >= 0) throw new Error(`Tree with root ${this.key} is not a binary search tree`);\n      });\n      this.left.checkNodeOrdering();\n    }\n    if (this.right) {\n      this.right.checkAllNodesFullfillCondition(k => {\n        if (this.compareKeys(k, this.key) <= 0) throw new Error(`Tree with root ${this.key} is not a binary search tree`);\n      });\n      this.right.checkNodeOrdering();\n    }\n  }\n\n  /**\n   * Check that all pointers are coherent in this tree\n   */\n  checkInternalPointers() {\n    if (this.left) {\n      if (this.left.parent !== this) throw new Error(`Parent pointer broken for key ${this.key}`);\n      this.left.checkInternalPointers();\n    }\n    if (this.right) {\n      if (this.right.parent !== this) throw new Error(`Parent pointer broken for key ${this.key}`);\n      this.right.checkInternalPointers();\n    }\n  }\n\n  /**\n   * Check that a tree is a BST as defined here (node ordering and pointer references)\n   */\n  checkIsBST() {\n    this.checkNodeOrdering();\n    this.checkInternalPointers();\n    if (this.parent) throw new Error(\"The root shouldn't have a parent\");\n  }\n\n  /**\n   * Get number of keys inserted\n   */\n  getNumberOfKeys() {\n    let res;\n    if (!Object.prototype.hasOwnProperty.call(this, 'key')) return 0;\n    res = 1;\n    if (this.left) res += this.left.getNumberOfKeys();\n    if (this.right) res += this.right.getNumberOfKeys();\n    return res;\n  }\n\n  /**\n   * Create a BST similar (i.e. same options except for key and value) to the current one\n   * Use the same constructor (i.e. BinarySearchTree, AVLTree etc)\n   * @param {Object} options see constructor\n   */\n  createSimilar(options) {\n    options = options || {};\n    options.unique = this.unique;\n    options.compareKeys = this.compareKeys;\n    options.checkValueEquality = this.checkValueEquality;\n    return new this.constructor(options);\n  }\n\n  /**\n   * Create the left child of this BST and return it\n   */\n  createLeftChild(options) {\n    const leftChild = this.createSimilar(options);\n    leftChild.parent = this;\n    this.left = leftChild;\n    return leftChild;\n  }\n\n  /**\n   * Create the right child of this BST and return it\n   */\n  createRightChild(options) {\n    const rightChild = this.createSimilar(options);\n    rightChild.parent = this;\n    this.right = rightChild;\n    return rightChild;\n  }\n\n  /**\n   * Insert a new element\n   */\n  insert(key, value) {\n    // Empty tree, insert as root\n    if (!Object.prototype.hasOwnProperty.call(this, 'key')) {\n      this.key = key;\n      this.data.push(value);\n      return;\n    }\n\n    // Same key as root\n    if (this.compareKeys(this.key, key) === 0) {\n      if (this.unique) {\n        const err = new Error(`Can't insert key ${JSON.stringify(key)}, it violates the unique constraint`);\n        err.key = key;\n        err.errorType = 'uniqueViolated';\n        throw err;\n      } else this.data.push(value);\n      return;\n    }\n    if (this.compareKeys(key, this.key) < 0) {\n      // Insert in left subtree\n      if (this.left) this.left.insert(key, value);else this.createLeftChild({\n        key: key,\n        value: value\n      });\n    } else {\n      // Insert in right subtree\n      if (this.right) this.right.insert(key, value);else this.createRightChild({\n        key: key,\n        value: value\n      });\n    }\n  }\n\n  /**\n   * Search for all data corresponding to a key\n   */\n  search(key) {\n    if (!Object.prototype.hasOwnProperty.call(this, 'key')) return [];\n    if (this.compareKeys(this.key, key) === 0) return this.data;\n    if (this.compareKeys(key, this.key) < 0) {\n      if (this.left) return this.left.search(key);else return [];\n    } else {\n      if (this.right) return this.right.search(key);else return [];\n    }\n  }\n\n  /**\n   * Return a function that tells whether a given key matches a lower bound\n   */\n  getLowerBoundMatcher(query) {\n    // No lower bound\n    if (!Object.prototype.hasOwnProperty.call(query, '$gt') && !Object.prototype.hasOwnProperty.call(query, '$gte')) return () => true;\n    if (Object.prototype.hasOwnProperty.call(query, '$gt') && Object.prototype.hasOwnProperty.call(query, '$gte')) {\n      if (this.compareKeys(query.$gte, query.$gt) === 0) return key => this.compareKeys(key, query.$gt) > 0;\n      if (this.compareKeys(query.$gte, query.$gt) > 0) return key => this.compareKeys(key, query.$gte) >= 0;else return key => this.compareKeys(key, query.$gt) > 0;\n    }\n    if (Object.prototype.hasOwnProperty.call(query, '$gt')) return key => this.compareKeys(key, query.$gt) > 0;else return key => this.compareKeys(key, query.$gte) >= 0;\n  }\n\n  /**\n   * Return a function that tells whether a given key matches an upper bound\n   */\n  getUpperBoundMatcher(query) {\n    // No lower bound\n    if (!Object.prototype.hasOwnProperty.call(query, '$lt') && !Object.prototype.hasOwnProperty.call(query, '$lte')) return () => true;\n    if (Object.prototype.hasOwnProperty.call(query, '$lt') && Object.prototype.hasOwnProperty.call(query, '$lte')) {\n      if (this.compareKeys(query.$lte, query.$lt) === 0) return key => this.compareKeys(key, query.$lt) < 0;\n      if (this.compareKeys(query.$lte, query.$lt) < 0) return key => this.compareKeys(key, query.$lte) <= 0;else return key => this.compareKeys(key, query.$lt) < 0;\n    }\n    if (Object.prototype.hasOwnProperty.call(query, '$lt')) return key => this.compareKeys(key, query.$lt) < 0;else return key => this.compareKeys(key, query.$lte) <= 0;\n  }\n\n  /**\n   * Get all data for a key between bounds\n   * Return it in key order\n   * @param {Object} query Mongo-style query where keys are $lt, $lte, $gt or $gte (other keys are not considered)\n   * @param {Functions} lbm/ubm matching functions calculated at the first recursive step\n   */\n  betweenBounds(query, lbm, ubm) {\n    const res = [];\n    if (!Object.prototype.hasOwnProperty.call(this, 'key')) return []; // Empty tree\n\n    lbm = lbm || this.getLowerBoundMatcher(query);\n    ubm = ubm || this.getUpperBoundMatcher(query);\n    if (lbm(this.key) && this.left) append(res, this.left.betweenBounds(query, lbm, ubm));\n    if (lbm(this.key) && ubm(this.key)) append(res, this.data);\n    if (ubm(this.key) && this.right) append(res, this.right.betweenBounds(query, lbm, ubm));\n    return res;\n  }\n\n  /**\n   * Delete the current node if it is a leaf\n   * Return true if it was deleted\n   */\n  deleteIfLeaf() {\n    if (this.left || this.right) return false;\n\n    // The leaf is itself a root\n    if (!this.parent) {\n      delete this.key;\n      this.data = [];\n      return true;\n    }\n    if (this.parent.left === this) this.parent.left = null;else this.parent.right = null;\n    return true;\n  }\n\n  /**\n   * Delete the current node if it has only one child\n   * Return true if it was deleted\n   */\n  deleteIfOnlyOneChild() {\n    let child;\n    if (this.left && !this.right) child = this.left;\n    if (!this.left && this.right) child = this.right;\n    if (!child) return false;\n\n    // Root\n    if (!this.parent) {\n      this.key = child.key;\n      this.data = child.data;\n      this.left = null;\n      if (child.left) {\n        this.left = child.left;\n        child.left.parent = this;\n      }\n      this.right = null;\n      if (child.right) {\n        this.right = child.right;\n        child.right.parent = this;\n      }\n      return true;\n    }\n    if (this.parent.left === this) {\n      this.parent.left = child;\n      child.parent = this.parent;\n    } else {\n      this.parent.right = child;\n      child.parent = this.parent;\n    }\n    return true;\n  }\n\n  /**\n   * Delete a key or just a value\n   * @param {Key} key\n   * @param {Value} value Optional. If not set, the whole key is deleted. If set, only this value is deleted\n   */\n  delete(key, value) {\n    const newData = [];\n    let replaceWith;\n    if (!Object.prototype.hasOwnProperty.call(this, 'key')) return;\n    if (this.compareKeys(key, this.key) < 0) {\n      if (this.left) this.left.delete(key, value);\n      return;\n    }\n    if (this.compareKeys(key, this.key) > 0) {\n      if (this.right) this.right.delete(key, value);\n      return;\n    }\n    if (!this.compareKeys(key, this.key) === 0) return;\n\n    // Delete only a value\n    if (this.data.length > 1 && value !== undefined) {\n      this.data.forEach(d => {\n        if (!this.checkValueEquality(d, value)) newData.push(d);\n      });\n      this.data = newData;\n      return;\n    }\n\n    // Delete the whole node\n    if (this.deleteIfLeaf()) return;\n    if (this.deleteIfOnlyOneChild()) return;\n\n    // We are in the case where the node to delete has two children\n    if (Math.random() >= 0.5) {\n      // Randomize replacement to avoid unbalancing the tree too much\n      // Use the in-order predecessor\n      replaceWith = this.left.getMaxKeyDescendant();\n      this.key = replaceWith.key;\n      this.data = replaceWith.data;\n      if (this === replaceWith.parent) {\n        // Special case\n        this.left = replaceWith.left;\n        if (replaceWith.left) replaceWith.left.parent = replaceWith.parent;\n      } else {\n        replaceWith.parent.right = replaceWith.left;\n        if (replaceWith.left) replaceWith.left.parent = replaceWith.parent;\n      }\n    } else {\n      // Use the in-order successor\n      replaceWith = this.right.getMinKeyDescendant();\n      this.key = replaceWith.key;\n      this.data = replaceWith.data;\n      if (this === replaceWith.parent) {\n        // Special case\n        this.right = replaceWith.right;\n        if (replaceWith.right) replaceWith.right.parent = replaceWith.parent;\n      } else {\n        replaceWith.parent.left = replaceWith.right;\n        if (replaceWith.right) replaceWith.right.parent = replaceWith.parent;\n      }\n    }\n  }\n\n  /**\n   * Execute a function on every node of the tree, in key order\n   * @param {Function} fn Signature: node. Most useful will probably be node.key and node.data\n   */\n  executeOnEveryNode(fn) {\n    if (this.left) this.left.executeOnEveryNode(fn);\n    fn(this);\n    if (this.right) this.right.executeOnEveryNode(fn);\n  }\n\n  /**\n   * Pretty print a tree\n   * @param {Boolean} printData To print the nodes' data along with the key\n   */\n  prettyPrint(printData, spacing) {\n    spacing = spacing || '';\n    console.log(`${spacing}* ${this.key}`);\n    if (printData) console.log(`${spacing}* ${this.data}`);\n    if (!this.left && !this.right) return;\n    if (this.left) this.left.prettyPrint(printData, `${spacing}  `);else console.log(`${spacing}  *`);\n    if (this.right) this.right.prettyPrint(printData, `${spacing}  `);else console.log(`${spacing}  *`);\n  }\n}\n\n// ================================\n// Methods used to test the tree\n// ================================\n\n// ============================================\n// Methods used to actually work on the tree\n// ============================================\n\n// Append all elements in toAppend to array\nfunction append(array, toAppend) {\n  for (let i = 0; i < toAppend.length; i += 1) {\n    array.push(toAppend[i]);\n  }\n}\n\n// Interface\nmodule.exports = BinarySearchTree;","map":{"version":3,"names":["customUtils","require","BinarySearchTree","constructor","options","left","right","parent","undefined","Object","prototype","hasOwnProperty","call","key","data","value","unique","compareKeys","defaultCompareKeysFunction","checkValueEquality","defaultCheckValueEquality","getMaxKeyDescendant","getMaxKey","getMinKeyDescendant","getMinKey","checkAllNodesFullfillCondition","test","checkNodeOrdering","k","Error","checkInternalPointers","checkIsBST","getNumberOfKeys","res","createSimilar","createLeftChild","leftChild","createRightChild","rightChild","insert","push","err","JSON","stringify","errorType","search","getLowerBoundMatcher","query","$gte","$gt","getUpperBoundMatcher","$lte","$lt","betweenBounds","lbm","ubm","append","deleteIfLeaf","deleteIfOnlyOneChild","child","delete","newData","replaceWith","length","forEach","d","Math","random","executeOnEveryNode","fn","prettyPrint","printData","spacing","console","log","array","toAppend","i","module","exports"],"sources":["C:/Users/benit/Music/arbisout/node_modules/@seald-io/binary-search-tree/lib/bst.js"],"sourcesContent":["/**\n * Simple binary search tree\n */\nconst customUtils = require('./customUtils')\n\nclass BinarySearchTree {\n  /**\n   * Constructor\n   * @param {Object} options Optional\n   * @param {Boolean}  options.unique Whether to enforce a 'unique' constraint on the key or not\n   * @param {Key}      options.key Initialize this BST's key with key\n   * @param {Value}    options.value Initialize this BST's data with [value]\n   * @param {Function} options.compareKeys Initialize this BST's compareKeys\n   */\n  constructor (options) {\n    options = options || {}\n\n    this.left = null\n    this.right = null\n    this.parent = options.parent !== undefined ? options.parent : null\n    if (Object.prototype.hasOwnProperty.call(options, 'key')) { this.key = options.key }\n    this.data = Object.prototype.hasOwnProperty.call(options, 'value') ? [options.value] : []\n    this.unique = options.unique || false\n\n    this.compareKeys = options.compareKeys || customUtils.defaultCompareKeysFunction\n    this.checkValueEquality = options.checkValueEquality || customUtils.defaultCheckValueEquality\n  }\n\n  /**\n   * Get the descendant with max key\n   */\n  getMaxKeyDescendant () {\n    if (this.right) return this.right.getMaxKeyDescendant()\n    else return this\n  }\n\n  /**\n   * Get the maximum key\n   */\n  getMaxKey () {\n    return this.getMaxKeyDescendant().key\n  }\n\n  /**\n   * Get the descendant with min key\n   */\n  getMinKeyDescendant () {\n    if (this.left) return this.left.getMinKeyDescendant()\n    else return this\n  }\n\n  /**\n   * Get the minimum key\n   */\n  getMinKey () {\n    return this.getMinKeyDescendant().key\n  }\n\n  /**\n   * Check that all nodes (incl. leaves) fullfil condition given by fn\n   * test is a function passed every (key, data) and which throws if the condition is not met\n   */\n  checkAllNodesFullfillCondition (test) {\n    if (!Object.prototype.hasOwnProperty.call(this, 'key')) return\n\n    test(this.key, this.data)\n    if (this.left) this.left.checkAllNodesFullfillCondition(test)\n    if (this.right) this.right.checkAllNodesFullfillCondition(test)\n  }\n\n  /**\n   * Check that the core BST properties on node ordering are verified\n   * Throw if they aren't\n   */\n  checkNodeOrdering () {\n    if (!Object.prototype.hasOwnProperty.call(this, 'key')) return\n\n    if (this.left) {\n      this.left.checkAllNodesFullfillCondition(k => {\n        if (this.compareKeys(k, this.key) >= 0) throw new Error(`Tree with root ${this.key} is not a binary search tree`)\n      })\n      this.left.checkNodeOrdering()\n    }\n\n    if (this.right) {\n      this.right.checkAllNodesFullfillCondition(k => {\n        if (this.compareKeys(k, this.key) <= 0) throw new Error(`Tree with root ${this.key} is not a binary search tree`)\n      })\n      this.right.checkNodeOrdering()\n    }\n  }\n\n  /**\n   * Check that all pointers are coherent in this tree\n   */\n  checkInternalPointers () {\n    if (this.left) {\n      if (this.left.parent !== this) throw new Error(`Parent pointer broken for key ${this.key}`)\n      this.left.checkInternalPointers()\n    }\n\n    if (this.right) {\n      if (this.right.parent !== this) throw new Error(`Parent pointer broken for key ${this.key}`)\n      this.right.checkInternalPointers()\n    }\n  }\n\n  /**\n   * Check that a tree is a BST as defined here (node ordering and pointer references)\n   */\n  checkIsBST () {\n    this.checkNodeOrdering()\n    this.checkInternalPointers()\n    if (this.parent) throw new Error(\"The root shouldn't have a parent\")\n  }\n\n  /**\n   * Get number of keys inserted\n   */\n  getNumberOfKeys () {\n    let res\n\n    if (!Object.prototype.hasOwnProperty.call(this, 'key')) return 0\n\n    res = 1\n    if (this.left) res += this.left.getNumberOfKeys()\n    if (this.right) res += this.right.getNumberOfKeys()\n\n    return res\n  }\n\n  /**\n   * Create a BST similar (i.e. same options except for key and value) to the current one\n   * Use the same constructor (i.e. BinarySearchTree, AVLTree etc)\n   * @param {Object} options see constructor\n   */\n  createSimilar (options) {\n    options = options || {}\n    options.unique = this.unique\n    options.compareKeys = this.compareKeys\n    options.checkValueEquality = this.checkValueEquality\n\n    return new this.constructor(options)\n  }\n\n  /**\n   * Create the left child of this BST and return it\n   */\n  createLeftChild (options) {\n    const leftChild = this.createSimilar(options)\n    leftChild.parent = this\n    this.left = leftChild\n\n    return leftChild\n  }\n\n  /**\n   * Create the right child of this BST and return it\n   */\n  createRightChild (options) {\n    const rightChild = this.createSimilar(options)\n    rightChild.parent = this\n    this.right = rightChild\n\n    return rightChild\n  }\n\n  /**\n   * Insert a new element\n   */\n  insert (key, value) {\n    // Empty tree, insert as root\n    if (!Object.prototype.hasOwnProperty.call(this, 'key')) {\n      this.key = key\n      this.data.push(value)\n      return\n    }\n\n    // Same key as root\n    if (this.compareKeys(this.key, key) === 0) {\n      if (this.unique) {\n        const err = new Error(`Can't insert key ${JSON.stringify(key)}, it violates the unique constraint`)\n        err.key = key\n        err.errorType = 'uniqueViolated'\n        throw err\n      } else this.data.push(value)\n      return\n    }\n\n    if (this.compareKeys(key, this.key) < 0) {\n      // Insert in left subtree\n      if (this.left) this.left.insert(key, value)\n      else this.createLeftChild({ key: key, value: value })\n    } else {\n      // Insert in right subtree\n      if (this.right) this.right.insert(key, value)\n      else this.createRightChild({ key: key, value: value })\n    }\n  }\n\n  /**\n   * Search for all data corresponding to a key\n   */\n  search (key) {\n    if (!Object.prototype.hasOwnProperty.call(this, 'key')) return []\n\n    if (this.compareKeys(this.key, key) === 0) return this.data\n\n    if (this.compareKeys(key, this.key) < 0) {\n      if (this.left) return this.left.search(key)\n      else return []\n    } else {\n      if (this.right) return this.right.search(key)\n      else return []\n    }\n  }\n\n  /**\n   * Return a function that tells whether a given key matches a lower bound\n   */\n  getLowerBoundMatcher (query) {\n    // No lower bound\n    if (!Object.prototype.hasOwnProperty.call(query, '$gt') && !Object.prototype.hasOwnProperty.call(query, '$gte')) return () => true\n\n    if (Object.prototype.hasOwnProperty.call(query, '$gt') && Object.prototype.hasOwnProperty.call(query, '$gte')) {\n      if (this.compareKeys(query.$gte, query.$gt) === 0) return key => this.compareKeys(key, query.$gt) > 0\n\n      if (this.compareKeys(query.$gte, query.$gt) > 0) return key => this.compareKeys(key, query.$gte) >= 0\n      else return key => this.compareKeys(key, query.$gt) > 0\n    }\n\n    if (Object.prototype.hasOwnProperty.call(query, '$gt')) return key => this.compareKeys(key, query.$gt) > 0\n    else return key => this.compareKeys(key, query.$gte) >= 0\n  }\n\n  /**\n   * Return a function that tells whether a given key matches an upper bound\n   */\n  getUpperBoundMatcher (query) {\n    // No lower bound\n    if (!Object.prototype.hasOwnProperty.call(query, '$lt') && !Object.prototype.hasOwnProperty.call(query, '$lte')) return () => true\n\n    if (Object.prototype.hasOwnProperty.call(query, '$lt') && Object.prototype.hasOwnProperty.call(query, '$lte')) {\n      if (this.compareKeys(query.$lte, query.$lt) === 0) return key => this.compareKeys(key, query.$lt) < 0\n\n      if (this.compareKeys(query.$lte, query.$lt) < 0) return key => this.compareKeys(key, query.$lte) <= 0\n      else return key => this.compareKeys(key, query.$lt) < 0\n    }\n\n    if (Object.prototype.hasOwnProperty.call(query, '$lt')) return key => this.compareKeys(key, query.$lt) < 0\n    else return key => this.compareKeys(key, query.$lte) <= 0\n  }\n\n  /**\n   * Get all data for a key between bounds\n   * Return it in key order\n   * @param {Object} query Mongo-style query where keys are $lt, $lte, $gt or $gte (other keys are not considered)\n   * @param {Functions} lbm/ubm matching functions calculated at the first recursive step\n   */\n  betweenBounds (query, lbm, ubm) {\n    const res = []\n\n    if (!Object.prototype.hasOwnProperty.call(this, 'key')) return [] // Empty tree\n\n    lbm = lbm || this.getLowerBoundMatcher(query)\n    ubm = ubm || this.getUpperBoundMatcher(query)\n\n    if (lbm(this.key) && this.left) append(res, this.left.betweenBounds(query, lbm, ubm))\n    if (lbm(this.key) && ubm(this.key)) append(res, this.data)\n    if (ubm(this.key) && this.right) append(res, this.right.betweenBounds(query, lbm, ubm))\n\n    return res\n  }\n\n  /**\n   * Delete the current node if it is a leaf\n   * Return true if it was deleted\n   */\n  deleteIfLeaf () {\n    if (this.left || this.right) return false\n\n    // The leaf is itself a root\n    if (!this.parent) {\n      delete this.key\n      this.data = []\n      return true\n    }\n\n    if (this.parent.left === this) this.parent.left = null\n    else this.parent.right = null\n\n    return true\n  }\n\n  /**\n   * Delete the current node if it has only one child\n   * Return true if it was deleted\n   */\n  deleteIfOnlyOneChild () {\n    let child\n\n    if (this.left && !this.right) child = this.left\n    if (!this.left && this.right) child = this.right\n    if (!child) return false\n\n    // Root\n    if (!this.parent) {\n      this.key = child.key\n      this.data = child.data\n\n      this.left = null\n      if (child.left) {\n        this.left = child.left\n        child.left.parent = this\n      }\n\n      this.right = null\n      if (child.right) {\n        this.right = child.right\n        child.right.parent = this\n      }\n\n      return true\n    }\n\n    if (this.parent.left === this) {\n      this.parent.left = child\n      child.parent = this.parent\n    } else {\n      this.parent.right = child\n      child.parent = this.parent\n    }\n\n    return true\n  }\n\n  /**\n   * Delete a key or just a value\n   * @param {Key} key\n   * @param {Value} value Optional. If not set, the whole key is deleted. If set, only this value is deleted\n   */\n  delete (key, value) {\n    const newData = []\n    let replaceWith\n\n    if (!Object.prototype.hasOwnProperty.call(this, 'key')) return\n\n    if (this.compareKeys(key, this.key) < 0) {\n      if (this.left) this.left.delete(key, value)\n      return\n    }\n\n    if (this.compareKeys(key, this.key) > 0) {\n      if (this.right) this.right.delete(key, value)\n      return\n    }\n\n    if (!this.compareKeys(key, this.key) === 0) return\n\n    // Delete only a value\n    if (this.data.length > 1 && value !== undefined) {\n      this.data.forEach(d => {\n        if (!this.checkValueEquality(d, value)) newData.push(d)\n      })\n      this.data = newData\n      return\n    }\n\n    // Delete the whole node\n    if (this.deleteIfLeaf()) return\n\n    if (this.deleteIfOnlyOneChild()) return\n\n    // We are in the case where the node to delete has two children\n    if (Math.random() >= 0.5) { // Randomize replacement to avoid unbalancing the tree too much\n      // Use the in-order predecessor\n      replaceWith = this.left.getMaxKeyDescendant()\n\n      this.key = replaceWith.key\n      this.data = replaceWith.data\n\n      if (this === replaceWith.parent) { // Special case\n        this.left = replaceWith.left\n        if (replaceWith.left) replaceWith.left.parent = replaceWith.parent\n      } else {\n        replaceWith.parent.right = replaceWith.left\n        if (replaceWith.left) replaceWith.left.parent = replaceWith.parent\n      }\n    } else {\n      // Use the in-order successor\n      replaceWith = this.right.getMinKeyDescendant()\n\n      this.key = replaceWith.key\n      this.data = replaceWith.data\n\n      if (this === replaceWith.parent) { // Special case\n        this.right = replaceWith.right\n        if (replaceWith.right) replaceWith.right.parent = replaceWith.parent\n      } else {\n        replaceWith.parent.left = replaceWith.right\n        if (replaceWith.right) replaceWith.right.parent = replaceWith.parent\n      }\n    }\n  }\n\n  /**\n   * Execute a function on every node of the tree, in key order\n   * @param {Function} fn Signature: node. Most useful will probably be node.key and node.data\n   */\n  executeOnEveryNode (fn) {\n    if (this.left) this.left.executeOnEveryNode(fn)\n    fn(this)\n    if (this.right) this.right.executeOnEveryNode(fn)\n  }\n\n  /**\n   * Pretty print a tree\n   * @param {Boolean} printData To print the nodes' data along with the key\n   */\n  prettyPrint (printData, spacing) {\n    spacing = spacing || ''\n\n    console.log(`${spacing}* ${this.key}`)\n    if (printData) console.log(`${spacing}* ${this.data}`)\n\n    if (!this.left && !this.right) return\n\n    if (this.left) this.left.prettyPrint(printData, `${spacing}  `)\n    else console.log(`${spacing}  *`)\n\n    if (this.right) this.right.prettyPrint(printData, `${spacing}  `)\n    else console.log(`${spacing}  *`)\n  }\n}\n\n// ================================\n// Methods used to test the tree\n// ================================\n\n// ============================================\n// Methods used to actually work on the tree\n// ============================================\n\n// Append all elements in toAppend to array\nfunction append (array, toAppend) {\n  for (let i = 0; i < toAppend.length; i += 1) {\n    array.push(toAppend[i])\n  }\n}\n\n// Interface\nmodule.exports = BinarySearchTree\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}