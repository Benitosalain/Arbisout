{"ast":null,"code":"const Waterfall = require('./waterfall');\n\n/**\n * Executes operations sequentially.\n * Has an option for a buffer that can be triggered afterwards.\n * @private\n */\nclass Executor {\n  /**\n   * Instantiates a new Executor.\n   */\n  constructor() {\n    /**\n     * If this.ready is `false`, then every task pushed will be buffered until this.processBuffer is called.\n     * @type {boolean}\n     * @private\n     */\n    this.ready = false;\n    /**\n     * The main queue\n     * @type {Waterfall}\n     * @private\n     */\n    this.queue = new Waterfall();\n    /**\n     * The buffer queue\n     * @type {Waterfall}\n     * @private\n     */\n    this.buffer = null;\n    /**\n     * Method to trigger the buffer processing.\n     *\n     * Do not be use directly, use `this.processBuffer` instead.\n     * @function\n     * @private\n     */\n    this._triggerBuffer = null;\n    this.resetBuffer();\n  }\n\n  /**\n   * If executor is ready, queue task (and process it immediately if executor was idle)\n   * If not, buffer task for later processing\n   * @param {AsyncFunction} task Function to execute\n   * @param {boolean} [forceQueuing = false] Optional (defaults to false) force executor to queue task even if it is not ready\n   * @return {Promise<*>}\n   * @async\n   * @see Executor#push\n   */\n  pushAsync(task, forceQueuing = false) {\n    if (this.ready || forceQueuing) return this.queue.waterfall(task)();else return this.buffer.waterfall(task)();\n  }\n\n  /**\n   * Queue all tasks in buffer (in the same order they came in)\n   * Automatically sets executor as ready\n   */\n  processBuffer() {\n    this.ready = true;\n    this._triggerBuffer();\n    this.queue.waterfall(() => this.buffer.guardian);\n  }\n\n  /**\n   * Removes all tasks queued up in the buffer\n   */\n  resetBuffer() {\n    this.buffer = new Waterfall();\n    this.buffer.chain(new Promise(resolve => {\n      this._triggerBuffer = resolve;\n    }));\n    if (this.ready) this._triggerBuffer();\n  }\n}\n\n// Interface\nmodule.exports = Executor;","map":{"version":3,"names":["Waterfall","require","Executor","constructor","ready","queue","buffer","_triggerBuffer","resetBuffer","pushAsync","task","forceQueuing","waterfall","processBuffer","guardian","chain","Promise","resolve","module","exports"],"sources":["C:/Users/benit/Music/arbisout/node_modules/@seald-io/nedb/lib/executor.js"],"sourcesContent":["const Waterfall = require('./waterfall')\n\n/**\n * Executes operations sequentially.\n * Has an option for a buffer that can be triggered afterwards.\n * @private\n */\nclass Executor {\n  /**\n   * Instantiates a new Executor.\n   */\n  constructor () {\n    /**\n     * If this.ready is `false`, then every task pushed will be buffered until this.processBuffer is called.\n     * @type {boolean}\n     * @private\n     */\n    this.ready = false\n    /**\n     * The main queue\n     * @type {Waterfall}\n     * @private\n     */\n    this.queue = new Waterfall()\n    /**\n     * The buffer queue\n     * @type {Waterfall}\n     * @private\n     */\n    this.buffer = null\n    /**\n     * Method to trigger the buffer processing.\n     *\n     * Do not be use directly, use `this.processBuffer` instead.\n     * @function\n     * @private\n     */\n    this._triggerBuffer = null\n    this.resetBuffer()\n  }\n\n  /**\n   * If executor is ready, queue task (and process it immediately if executor was idle)\n   * If not, buffer task for later processing\n   * @param {AsyncFunction} task Function to execute\n   * @param {boolean} [forceQueuing = false] Optional (defaults to false) force executor to queue task even if it is not ready\n   * @return {Promise<*>}\n   * @async\n   * @see Executor#push\n   */\n  pushAsync (task, forceQueuing = false) {\n    if (this.ready || forceQueuing) return this.queue.waterfall(task)()\n    else return this.buffer.waterfall(task)()\n  }\n\n  /**\n   * Queue all tasks in buffer (in the same order they came in)\n   * Automatically sets executor as ready\n   */\n  processBuffer () {\n    this.ready = true\n    this._triggerBuffer()\n    this.queue.waterfall(() => this.buffer.guardian)\n  }\n\n  /**\n   * Removes all tasks queued up in the buffer\n   */\n  resetBuffer () {\n    this.buffer = new Waterfall()\n    this.buffer.chain(new Promise(resolve => {\n      this._triggerBuffer = resolve\n    }))\n    if (this.ready) this._triggerBuffer()\n  }\n}\n\n// Interface\nmodule.exports = Executor\n"],"mappings":"AAAA,MAAMA,SAAS,GAAGC,OAAO,CAAC,aAAa,CAAC;;AAExC;AACA;AACA;AACA;AACA;AACA,MAAMC,QAAQ,CAAC;EACb;AACF;AACA;EACEC,WAAWA,CAAA,EAAI;IACb;AACJ;AACA;AACA;AACA;IACI,IAAI,CAACC,KAAK,GAAG,KAAK;IAClB;AACJ;AACA;AACA;AACA;IACI,IAAI,CAACC,KAAK,GAAG,IAAIL,SAAS,CAAC,CAAC;IAC5B;AACJ;AACA;AACA;AACA;IACI,IAAI,CAACM,MAAM,GAAG,IAAI;IAClB;AACJ;AACA;AACA;AACA;AACA;AACA;IACI,IAAI,CAACC,cAAc,GAAG,IAAI;IAC1B,IAAI,CAACC,WAAW,CAAC,CAAC;EACpB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,SAASA,CAAEC,IAAI,EAAEC,YAAY,GAAG,KAAK,EAAE;IACrC,IAAI,IAAI,CAACP,KAAK,IAAIO,YAAY,EAAE,OAAO,IAAI,CAACN,KAAK,CAACO,SAAS,CAACF,IAAI,CAAC,CAAC,CAAC,MAC9D,OAAO,IAAI,CAACJ,MAAM,CAACM,SAAS,CAACF,IAAI,CAAC,CAAC,CAAC;EAC3C;;EAEA;AACF;AACA;AACA;EACEG,aAAaA,CAAA,EAAI;IACf,IAAI,CAACT,KAAK,GAAG,IAAI;IACjB,IAAI,CAACG,cAAc,CAAC,CAAC;IACrB,IAAI,CAACF,KAAK,CAACO,SAAS,CAAC,MAAM,IAAI,CAACN,MAAM,CAACQ,QAAQ,CAAC;EAClD;;EAEA;AACF;AACA;EACEN,WAAWA,CAAA,EAAI;IACb,IAAI,CAACF,MAAM,GAAG,IAAIN,SAAS,CAAC,CAAC;IAC7B,IAAI,CAACM,MAAM,CAACS,KAAK,CAAC,IAAIC,OAAO,CAACC,OAAO,IAAI;MACvC,IAAI,CAACV,cAAc,GAAGU,OAAO;IAC/B,CAAC,CAAC,CAAC;IACH,IAAI,IAAI,CAACb,KAAK,EAAE,IAAI,CAACG,cAAc,CAAC,CAAC;EACvC;AACF;;AAEA;AACAW,MAAM,CAACC,OAAO,GAAGjB,QAAQ","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}