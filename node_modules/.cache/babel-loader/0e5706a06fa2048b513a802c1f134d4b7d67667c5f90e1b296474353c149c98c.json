{"ast":null,"code":"/**\n * Utility functions for all environments.\n * This replaces the underscore dependency.\n *\n * @module utils\n * @private\n */\n\n/**\n * @callback IterateeFunction\n * @param {*} arg\n * @return {*}\n */\n\n/**\n * Produces a duplicate-free version of the array, using === to test object equality. In particular only the first\n * occurrence of each value is kept. If you want to compute unique items based on a transformation, pass an iteratee\n * function.\n *\n * Heavily inspired by {@link https://underscorejs.org/#uniq}.\n * @param {Array} array\n * @param {IterateeFunction} [iteratee] transformation applied to every element before checking for duplicates. This will not\n * transform the items in the result.\n * @return {Array}\n * @alias module:utils.uniq\n */\nconst uniq = (array, iteratee) => {\n  if (iteratee) return [...new Map(array.map(x => [iteratee(x), x])).values()];else return [...new Set(array)];\n};\n/**\n * Returns true if arg is an Object. Note that JavaScript arrays and functions are objects, while (normal) strings\n * and numbers are not.\n *\n * Heavily inspired by {@link https://underscorejs.org/#isObject}.\n * @param {*} arg\n * @return {boolean}\n */\nconst isObject = arg => typeof arg === 'object' && arg !== null;\n\n/**\n * Returns true if d is a Date.\n *\n * Heavily inspired by {@link https://underscorejs.org/#isDate}.\n * @param {*} d\n * @return {boolean}\n * @alias module:utils.isDate\n */\nconst isDate = d => isObject(d) && Object.prototype.toString.call(d) === '[object Date]';\n\n/**\n * Returns true if re is a RegExp.\n *\n * Heavily inspired by {@link https://underscorejs.org/#isRegExp}.\n * @param {*} re\n * @return {boolean}\n * @alias module:utils.isRegExp\n */\nconst isRegExp = re => isObject(re) && Object.prototype.toString.call(re) === '[object RegExp]';\n\n/**\n * Return a copy of the object filtered using the given keys.\n *\n * @param {object} object\n * @param {string[]} keys\n * @return {object}\n */\nconst pick = (object, keys) => {\n  return keys.reduce((obj, key) => {\n    if (object && Object.prototype.hasOwnProperty.call(object, key)) {\n      obj[key] = object[key];\n    }\n    return obj;\n  }, {});\n};\nconst filterIndexNames = indexNames => ([k, v]) => !!(typeof v === 'string' || typeof v === 'number' || typeof v === 'boolean' || isDate(v) || v === null) && indexNames.includes(k);\nmodule.exports.uniq = uniq;\nmodule.exports.isDate = isDate;\nmodule.exports.isRegExp = isRegExp;\nmodule.exports.pick = pick;\nmodule.exports.filterIndexNames = filterIndexNames;","map":{"version":3,"names":["uniq","array","iteratee","Map","map","x","values","Set","isObject","arg","isDate","d","Object","prototype","toString","call","isRegExp","re","pick","object","keys","reduce","obj","key","hasOwnProperty","filterIndexNames","indexNames","k","v","includes","module","exports"],"sources":["C:/Users/benit/Music/arbisout/node_modules/@seald-io/nedb/lib/utils.js"],"sourcesContent":["/**\n * Utility functions for all environments.\n * This replaces the underscore dependency.\n *\n * @module utils\n * @private\n */\n\n/**\n * @callback IterateeFunction\n * @param {*} arg\n * @return {*}\n */\n\n/**\n * Produces a duplicate-free version of the array, using === to test object equality. In particular only the first\n * occurrence of each value is kept. If you want to compute unique items based on a transformation, pass an iteratee\n * function.\n *\n * Heavily inspired by {@link https://underscorejs.org/#uniq}.\n * @param {Array} array\n * @param {IterateeFunction} [iteratee] transformation applied to every element before checking for duplicates. This will not\n * transform the items in the result.\n * @return {Array}\n * @alias module:utils.uniq\n */\nconst uniq = (array, iteratee) => {\n  if (iteratee) return [...(new Map(array.map(x => [iteratee(x), x]))).values()]\n  else return [...new Set(array)]\n}\n/**\n * Returns true if arg is an Object. Note that JavaScript arrays and functions are objects, while (normal) strings\n * and numbers are not.\n *\n * Heavily inspired by {@link https://underscorejs.org/#isObject}.\n * @param {*} arg\n * @return {boolean}\n */\nconst isObject = arg => typeof arg === 'object' && arg !== null\n\n/**\n * Returns true if d is a Date.\n *\n * Heavily inspired by {@link https://underscorejs.org/#isDate}.\n * @param {*} d\n * @return {boolean}\n * @alias module:utils.isDate\n */\nconst isDate = d => isObject(d) && Object.prototype.toString.call(d) === '[object Date]'\n\n/**\n * Returns true if re is a RegExp.\n *\n * Heavily inspired by {@link https://underscorejs.org/#isRegExp}.\n * @param {*} re\n * @return {boolean}\n * @alias module:utils.isRegExp\n */\nconst isRegExp = re => isObject(re) && Object.prototype.toString.call(re) === '[object RegExp]'\n\n/**\n * Return a copy of the object filtered using the given keys.\n *\n * @param {object} object\n * @param {string[]} keys\n * @return {object}\n */\nconst pick = (object, keys) => {\n  return keys.reduce((obj, key) => {\n    if (object && Object.prototype.hasOwnProperty.call(object, key)) {\n      obj[key] = object[key]\n    }\n    return obj\n  }, {})\n}\n\nconst filterIndexNames = (indexNames) => ([k, v]) => !!(typeof v === 'string' || typeof v === 'number' || typeof v === 'boolean' || isDate(v) || v === null) &&\nindexNames.includes(k)\n\nmodule.exports.uniq = uniq\nmodule.exports.isDate = isDate\nmodule.exports.isRegExp = isRegExp\nmodule.exports.pick = pick\nmodule.exports.filterIndexNames = filterIndexNames\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMA,IAAI,GAAGA,CAACC,KAAK,EAAEC,QAAQ,KAAK;EAChC,IAAIA,QAAQ,EAAE,OAAO,CAAC,GAAI,IAAIC,GAAG,CAACF,KAAK,CAACG,GAAG,CAACC,CAAC,IAAI,CAACH,QAAQ,CAACG,CAAC,CAAC,EAAEA,CAAC,CAAC,CAAC,CAAC,CAAEC,MAAM,CAAC,CAAC,CAAC,MACzE,OAAO,CAAC,GAAG,IAAIC,GAAG,CAACN,KAAK,CAAC,CAAC;AACjC,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMO,QAAQ,GAAGC,GAAG,IAAI,OAAOA,GAAG,KAAK,QAAQ,IAAIA,GAAG,KAAK,IAAI;;AAE/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,MAAM,GAAGC,CAAC,IAAIH,QAAQ,CAACG,CAAC,CAAC,IAAIC,MAAM,CAACC,SAAS,CAACC,QAAQ,CAACC,IAAI,CAACJ,CAAC,CAAC,KAAK,eAAe;;AAExF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMK,QAAQ,GAAGC,EAAE,IAAIT,QAAQ,CAACS,EAAE,CAAC,IAAIL,MAAM,CAACC,SAAS,CAACC,QAAQ,CAACC,IAAI,CAACE,EAAE,CAAC,KAAK,iBAAiB;;AAE/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,IAAI,GAAGA,CAACC,MAAM,EAAEC,IAAI,KAAK;EAC7B,OAAOA,IAAI,CAACC,MAAM,CAAC,CAACC,GAAG,EAAEC,GAAG,KAAK;IAC/B,IAAIJ,MAAM,IAAIP,MAAM,CAACC,SAAS,CAACW,cAAc,CAACT,IAAI,CAACI,MAAM,EAAEI,GAAG,CAAC,EAAE;MAC/DD,GAAG,CAACC,GAAG,CAAC,GAAGJ,MAAM,CAACI,GAAG,CAAC;IACxB;IACA,OAAOD,GAAG;EACZ,CAAC,EAAE,CAAC,CAAC,CAAC;AACR,CAAC;AAED,MAAMG,gBAAgB,GAAIC,UAAU,IAAK,CAAC,CAACC,CAAC,EAAEC,CAAC,CAAC,KAAK,CAAC,EAAE,OAAOA,CAAC,KAAK,QAAQ,IAAI,OAAOA,CAAC,KAAK,QAAQ,IAAI,OAAOA,CAAC,KAAK,SAAS,IAAIlB,MAAM,CAACkB,CAAC,CAAC,IAAIA,CAAC,KAAK,IAAI,CAAC,IAC5JF,UAAU,CAACG,QAAQ,CAACF,CAAC,CAAC;AAEtBG,MAAM,CAACC,OAAO,CAAC/B,IAAI,GAAGA,IAAI;AAC1B8B,MAAM,CAACC,OAAO,CAACrB,MAAM,GAAGA,MAAM;AAC9BoB,MAAM,CAACC,OAAO,CAACf,QAAQ,GAAGA,QAAQ;AAClCc,MAAM,CAACC,OAAO,CAACb,IAAI,GAAGA,IAAI;AAC1BY,MAAM,CAACC,OAAO,CAACN,gBAAgB,GAAGA,gBAAgB","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}